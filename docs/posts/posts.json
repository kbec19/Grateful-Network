[
  {
    "path": "posts/statistics/",
    "title": "Statistical Analysis",
    "description": "Using Univariate Conditional Uniform Graph Tests",
    "author": [
      {
        "name": "Kristina Becvar",
        "url": "http://gratefulnetwork.live/"
      }
    ],
    "date": "2022-05-10",
    "categories": [
      "network analytics",
      "statistics",
      "CUG test",
      "statnet"
    ],
    "contents": "\r\n\r\nContents\r\nLoading Networks\r\nAffiliation Matrix\r\nBipartite Projection\r\nCreate statnet Object\r\n\r\nCentrality and Node\r\nData\r\nComparing Network\r\nProperties\r\nCreate t-stat Function\r\nNetwork Transitivity to\r\nNull\r\nPlot Results\r\nInspect Details\r\nT-Stat Test\r\nEvaluation\r\n\r\nNetwork Degree\r\nCentralization to Null\r\nPlot Results\r\nInspect Details\r\nT-Stat Test\r\nEvaluation\r\n\r\nBetweenness Centrality\r\nPlot Results\r\nInspect Details\r\nT-Stat Test\r\nEvaluation\r\n\r\nTransitivity\r\nPlot Results\r\nInspect Details\r\nT-Stat Test\r\nEvaluation\r\n\r\nMultiple Evaluations\r\nVisualization\r\n\r\n\r\n\r\n\r\n\r\nShow code\r\n\r\nlibrary(ggplot2) \r\nlibrary(readr) \r\nlibrary(statnet)\r\nlibrary(ggraph)\r\nlibrary(tidyverse)\r\nlibrary(ergm)\r\nlibrary(dplyr)\r\nlibrary(corrr)\r\nlibrary(magrittr)\r\n\r\nsuppressWarnings(expr)\r\n\r\n\r\n\r\nLoading Networks\r\nI previously analyzed the network using igraph and statnet, and need\r\nto make a decision about which package serves the network best.\r\nAffiliation Matrix\r\nLoading the dataset and creating the network to begin my\r\nanalysis:\r\n\r\n\r\nShow code\r\n\r\ngd_affiliation <- read.csv('gd_affiliation_matrix.csv', row.names = 1, header = TRUE, check.names = FALSE)\r\ngd_matrix <- as.matrix(gd_affiliation)\r\n\r\n\r\n\r\nBipartite Projection\r\n\r\n\r\nShow code\r\n\r\ngd_projection <- gd_matrix%*%t(gd_matrix)\r\nwrite.csv(gd_projection, file = \"gd_projection.csv\")\r\n\r\n\r\n\r\nCreate statnet Object\r\n\r\n\r\nShow code\r\n\r\nset.seed(11)\r\ngd_statnet <- as.network(gd_projection,\r\n               directed = FALSE, \r\n               bipartite = FALSE,\r\n               loops = FALSE,\r\n               connected = TRUE)\r\n\r\n\r\n\r\nCentrality and Node Data\r\nI am going to load the data frame I saved from the statnet package\r\nanalysis as well as a dataframe with key comparable results from each\r\npackage\r\n\r\n\r\nShow code\r\n\r\ngd_stat_nodes <- read.csv(\"gd_stat_nodes.csv\")\r\ngd_compare <- read.csv(\"gd_comparison_packages.csv\")\r\n\r\n\r\n\r\nComparing Network Properties\r\nIn the semester assignment, we looked at what to do if we are\r\ninterested in testing whether or not a specific network property, such\r\nas transitivity, is higher in the network we are interested in than we\r\nwould expect from a random network. To test our network against a null\r\nhypothesis, we can use the function cug.test() and set the parameters on\r\nwhich we plan to condition. Possible parameters for this function\r\ninclude: size, edges, and dyad.census for sna/statnet.\r\nCreate t-stat Function\r\n\r\n\r\nShow code\r\n\r\ncug.t<-function(cug.object){\r\n  (cug.object$obs.stat-mean(cug.object$rep.stat))/sd(cug.object$rep.stat)\r\n}\r\n\r\n\r\n\r\nNetwork Transitivity to Null\r\nComparing transitivity to null conditional on size\r\n\r\n\r\nShow code\r\n\r\n#compare network transitivity to null conditional on size\r\ntrans.cug<-cug.test(gd_projection,FUN=gtrans,mode=\"graph\",cmode=\"size\")\r\ntrans.cug\r\n\r\n\r\n\r\nUnivariate Conditional Uniform Graph Test\r\n\r\nConditioning Method: size \r\nGraph Type: graph \r\nDiagonal Used: FALSE \r\nReplications: 1000 \r\n\r\nObserved Value: 0.5240964 \r\nPr(X>=Obs): 0.189 \r\nPr(X<=Obs): 0.811 \r\n\r\nPlot Results\r\n\r\n\r\nShow code\r\n\r\nplot(trans.cug)\r\n\r\n\r\n\r\n\r\nInspect Details\r\n\r\n\r\nShow code\r\n\r\n#inspect CUG test\r\ntrans.cug\r\n\r\n\r\n\r\nUnivariate Conditional Uniform Graph Test\r\n\r\nConditioning Method: size \r\nGraph Type: graph \r\nDiagonal Used: FALSE \r\nReplications: 1000 \r\n\r\nObserved Value: 0.5240964 \r\nPr(X>=Obs): 0.189 \r\nPr(X<=Obs): 0.811 \r\n\r\nT-Stat Test\r\n\r\n\r\nShow code\r\n\r\n#inspect CUG test\r\ncug.t(trans.cug)\r\n\r\n\r\n[1] 0.8395548\r\n\r\nEvaluation\r\nThere is a reasonable probability that the observed network\r\ntransitivity of 0.524 could be randomly generated, conditional only on\r\nthe size of the network. In this case, I cannot accept the alternative\r\nhypothesis that the observed transitivity is higher than would be\r\nexpected from a random network. In fact, the probability that X <=\r\n0.524 is 19.6% and the probability that x >= 0.524 is 80.4%. The\r\nt-stat evaluation tells us that the observed transitivity value is less\r\nthan 1 standard error away from what we would expect, on average.\r\nNetwork Degree\r\nCentralization to Null\r\nComparing network degree centralization to null conditional on\r\nsize\r\n\r\n\r\nShow code\r\n\r\n#compare network degree centralization to null conditional on size\r\nc.degree.cug <-cug.test(gd_projection,FUN=centralization,  FUN.arg=list(FUN=degree, cmode=\"degree\"), mode=\"graph\", cmode=\"size\")\r\n\r\n\r\n\r\nPlot Results\r\n\r\n\r\nShow code\r\n\r\n#plot vs simulation results\r\nplot(c.degree.cug)\r\n\r\n\r\n\r\n\r\nInspect Details\r\n\r\n\r\nShow code\r\n\r\n#inspect CUG test\r\nc.degree.cug\r\n\r\n\r\n\r\nUnivariate Conditional Uniform Graph Test\r\n\r\nConditioning Method: size \r\nGraph Type: graph \r\nDiagonal Used: FALSE \r\nReplications: 1000 \r\n\r\nObserved Value: 5.206522 \r\nPr(X>=Obs): 0 \r\nPr(X<=Obs): 1 \r\n\r\nT-Stat Test\r\n\r\n\r\nShow code\r\n\r\n#t-stat between observed and simulated networks\r\ncug.t(c.degree.cug)\r\n\r\n\r\n[1] 101.9499\r\n\r\nEvaluation\r\nThere is an extremely remote probability that the observed network\r\ndegree centrality of 5.21 could be randomly generated, conditional only\r\non the size of the network. In this case, I can accept the alternative\r\nhypothesis that the observed network degree centrality is higher than\r\nwould be expected from a random network. .\r\nBetweenness Centrality\r\nComparing network betweenness centralization to null conditional on\r\nsize\r\n\r\n\r\nShow code\r\n\r\n#compare network betweenness centralization to null conditional on size\r\nb.degree.cug <-cug.test(gd_projection,FUN=centralization,  FUN.arg=list(FUN=betweenness, cmode=\"undirected\"), mode=\"graph\", cmode=\"size\", reps=100) \r\n\r\n\r\n\r\nPlot Results\r\n\r\n\r\nShow code\r\n\r\n#plot vs simulation results\r\nplot(b.degree.cug)\r\n\r\n\r\n\r\n\r\nInspect Details\r\n\r\n\r\nShow code\r\n\r\n#inspect CUG test\r\nb.degree.cug\r\n\r\n\r\n\r\nUnivariate Conditional Uniform Graph Test\r\n\r\nConditioning Method: size \r\nGraph Type: graph \r\nDiagonal Used: FALSE \r\nReplications: 100 \r\n\r\nObserved Value: 0.3759561 \r\nPr(X>=Obs): 0 \r\nPr(X<=Obs): 1 \r\n\r\nT-Stat Test\r\n\r\n\r\nShow code\r\n\r\n#t-stat between observed and simulated networks\r\ncug.t(b.degree.cug)\r\n\r\n\r\n[1] 34.06653\r\n\r\nEvaluation\r\nAgain, there is an extremely remote probability that the observed\r\nbetweenness centrality of 0.376 could be randomly generated, conditional\r\nonly on the size of the network. In this case, I can accept the\r\nalternative hypothesis that the observed network degree centrality is\r\nhigher than would be expected from a random network. This makes sense\r\nwith the rest of my network evaluations.\r\nTransitivity\r\nComparing transitivity to null conditional on dyad\r\n\r\n\r\nShow code\r\n\r\nt.degree.cug <-cug.test(gd_projection,FUN=gtrans, mode=\"graph\", cmode=\"dyad\", reps=100) \r\n\r\n\r\n\r\nPlot Results\r\n\r\n\r\nShow code\r\n\r\n#plot vs simulation results\r\nplot(t.degree.cug)\r\n\r\n\r\n\r\n\r\nInspect Details\r\n\r\n\r\nShow code\r\n\r\n#inspect CUG test\r\nt.degree.cug\r\n\r\n\r\n\r\nUnivariate Conditional Uniform Graph Test\r\n\r\nConditioning Method: dyad.census \r\nGraph Type: graph \r\nDiagonal Used: FALSE \r\nReplications: 100 \r\n\r\nObserved Value: 0.5240964 \r\nPr(X>=Obs): 0 \r\nPr(X<=Obs): 1 \r\n\r\nT-Stat Test\r\n\r\n\r\nShow code\r\n\r\n#t-stat between observed and simulated networks\r\ncug.t(t.degree.cug)\r\n\r\n\r\n[1] 8.463895\r\n\r\nEvaluation\r\nUnlike the first evaluation of transitivity on size, this evaluation\r\nof transivity on dyad gives a result that is more in line with\r\nsubsequent calculations.\r\nMultiple Evaluations\r\nFor my research in particular, I want to look at the measures of\r\ncentrality and through the different modes of evaluation.\r\n\r\n\r\nShow code\r\n\r\ncug_cent_size <- cug.test(gd_statnet,\r\n                       centralization,\r\n                       FUN.arg=list(FUN=degree), \r\n                       mode=\"graph\", \r\n                       cmode=\"size\")\r\ncug_cent_edge <- cug.test(gd_statnet,\r\n                        centralization,\r\n                        FUN.arg=list(FUN=degree), \r\n                        mode=\"graph\", \r\n                        cmode=\"edges\")\r\ncug_cent_dyad <- cug.test(gd_statnet,\r\n                       centralization,\r\n                       FUN.arg=list(FUN=degree), \r\n                       mode=\"graph\", \r\n                       cmode=\"dyad.census\")\r\n\r\n\r\n\r\nVisualization\r\n\r\n\r\nShow code\r\n\r\ndegree_centralization <- c(cug_cent_size$obs.stat,\r\n                        cug_cent_edge$obs.stat, \r\n                        cug_cent_dyad$obs.stat)\r\n\r\nrt_tail <- c(cug_cent_size$pgteobs, \r\n             cug_cent_edge$pgteobs, \r\n             cug_cent_dyad$pgteobs)\r\n\r\nlt_tail <- c(cug_cent_size$plteobs, \r\n             cug_cent_edge$plteobs, \r\n             cug_cent_dyad$plteobs)\r\n\r\ncentrality <- cbind(degree_centralization,\r\n                     rt_tail, \r\n                     lt_tail)\r\n\r\nrownames(centrality) <- c(\"Size\", \"Edges\", \"Dyads\")\r\n\r\npar(mfrow=c(1,3))\r\nplot(cug_cent_size, main=\"Centrality \\nConditioned on Size\" )\r\nplot(cug_cent_edge, main=\"Centrality \\nConditioned on Edges\" )\r\nplot(cug_cent_dyad, main=\"Centrality \\nConditioned on Dyads\" )\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/statistics/gtrans.png",
    "last_modified": "2022-05-11T02:25:08-04:00",
    "input_file": {},
    "preview_width": 565,
    "preview_height": 349
  },
  {
    "path": "posts/igraph-analysis/",
    "title": "Network Differences and Advanced Analysis",
    "description": "Comparing Network Packages and Moving Forward with Clustering, Blockmodels, Roles, and Community Structures",
    "author": [
      {
        "name": "Kristina Becvar",
        "url": "http://gratefulnetwork.live/"
      }
    ],
    "date": "2022-04-25",
    "categories": [
      "network analytics",
      "network visualization",
      "blockmodels",
      "roles",
      "community",
      "clustering",
      "igraph",
      "statnet"
    ],
    "contents": "\r\n\r\nContents\r\nLoading Networks\r\nAffiliation Matrix\r\nBipartite Projection\r\nCreate igraph Object\r\nCreate statnet Object\r\n\r\nLoading Data\r\nCentrality and Node\r\nData\r\nCorrelations of\r\nCentrality Measures\r\nDegree\r\nEigenvector Centrality\r\nBetweenness\r\nCloseness\r\nBonacich Power\r\nEvaluation\r\n\r\nStructural Equivalence\r\n“Complete”\r\n“Average”\r\n“Single”\r\n“Ward.D”\r\n\r\nPartition Using Clustering\r\nward.D, Height= 15\r\nward.D, Height= 10\r\nHeight= 20\r\n\r\nBlockmodel Partitions\r\n2-partition blockmodel\r\n5-partition blockmodel\r\nconcoR-Based Partitions\r\n\r\nBlockmodeling Choice\r\nBlockmodel\r\nVisualization\r\n\r\nCommunity\r\nFast and Greedy\r\nCommunity\r\nWalktrap Community\r\nDetection and Plot\r\nCollect & Compare\r\nModularity Scores\r\nLeading\r\nLabel Propagation Community Detection\r\nEdge Betweenness\r\nCommunity Detection\r\nEigenvector Community\r\nDetection\r\n\r\nSpinglass Community\r\nDetection\r\nCompare\r\nCommunity Partitions - Eigenvector and Spinglass\r\nLouvain Community\r\nClustering\r\nConclusion\r\nEvaluation of\r\nModularity\r\n\r\n\r\nFurther Analysis\r\nCommunity Membership\r\nK-core Decomposition\r\n\r\n\r\n\r\n\r\nShow code\r\n\r\nlibrary(ggplot2) \r\nlibrary(readr) \r\nlibrary(igraph)\r\nlibrary(statnet)\r\nlibrary(ggraph)\r\nlibrary(tidyverse)\r\nlibrary(ergm)\r\nlibrary(dplyr)\r\nlibrary(corrr)\r\nlibrary(magrittr)\r\n\r\nsuppressWarnings(expr)\r\n\r\n\r\n\r\nLoading Networks\r\nI previously analyzed the network using igraph and statnet, and need\r\nto make a decision about which package serves the network best.\r\nAffiliation Matrix\r\nLoading the dataset and creating the network to begin my\r\nanalysis:\r\n\r\n\r\nShow code\r\n\r\ngd_affiliation <- read.csv('gd_affiliation_matrix.csv', row.names = 1, header = TRUE, check.names = FALSE)\r\ngd_matrix <- as.matrix(gd_affiliation)\r\n\r\n\r\n\r\nBipartite Projection\r\n\r\n\r\nShow code\r\n\r\ngd_projection <- gd_matrix%*%t(gd_matrix)\r\nwrite.csv(gd_projection, file = \"gd_projection.csv\")\r\n\r\n\r\n\r\nCreate igraph Object\r\n\r\n\r\nShow code\r\n\r\nset.seed(11)\r\ngd_igraph <- graph.adjacency(gd_projection,mode=\"undirected\", weighted = NULL)\r\n\r\n\r\n\r\nCreate statnet Object\r\n\r\n\r\nShow code\r\n\r\nset.seed(11)\r\ngd_statnet <- as.network(gd_projection,\r\n               directed = FALSE, \r\n               bipartite = FALSE,\r\n               loops = FALSE,\r\n               connected = TRUE)\r\n\r\n\r\n\r\nLoading Data\r\nCentrality and Node Data\r\nI am going to load the data frame I saved from both igraph and\r\nstatnet package analysis as well as a dataframe with key comparable\r\nresults from each package\r\n\r\n\r\nShow code\r\n\r\ngd_ig_nodes <- read.csv(\"gd_ig_nodes.csv\")\r\ngd_stat_nodes <- read.csv(\"gd_stat_nodes.csv\")\r\ngd_compare <- read.csv(\"gd_comparison_packages.csv\")\r\n\r\n\r\n\r\nCorrelations of Centrality\r\nMeasures\r\nDegree\r\n\r\n\r\nShow code\r\n\r\ndegree_lm <- lm(igraph_degree~statnet_degree, data = gd_compare)\r\nsummary(degree_lm)\r\n\r\n\r\n\r\nCall:\r\nlm(formula = igraph_degree ~ statnet_degree, data = gd_compare)\r\n\r\nResiduals:\r\n    Min      1Q  Median      3Q     Max \r\n-31.415 -16.319   0.516   7.502  76.626 \r\n\r\nCoefficients:\r\n               Estimate Std. Error t value Pr(>|t|)    \r\n(Intercept)    -14.4884     7.3890  -1.961   0.0621 .  \r\nstatnet_degree   3.9931     0.5505   7.254 2.21e-07 ***\r\n---\r\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\r\n\r\nResidual standard error: 23.36 on 23 degrees of freedom\r\nMultiple R-squared:  0.6958,    Adjusted R-squared:  0.6826 \r\nF-statistic: 52.62 on 1 and 23 DF,  p-value: 2.206e-07\r\n\r\nEigenvector Centrality\r\n\r\n\r\nShow code\r\n\r\neigen_lm <- lm(ig_eigen~stat_eigen, data = gd_compare)\r\nsummary(eigen_lm)\r\n\r\n\r\n\r\nCall:\r\nlm(formula = ig_eigen ~ stat_eigen, data = gd_compare)\r\n\r\nResiduals:\r\n       Min         1Q     Median         3Q        Max \r\n-3.071e-17 -1.200e-17 -5.143e-18  3.155e-18  1.343e-16 \r\n\r\nCoefficients:\r\n             Estimate Std. Error   t value Pr(>|t|)    \r\n(Intercept) 4.441e-17  1.015e-17 4.377e+00  0.00022 ***\r\nstat_eigen  1.000e+00  5.073e-17 1.971e+16  < 2e-16 ***\r\n---\r\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\r\n\r\nResidual standard error: 3.023e-17 on 23 degrees of freedom\r\nMultiple R-squared:      1, Adjusted R-squared:      1 \r\nF-statistic: 3.886e+32 on 1 and 23 DF,  p-value: < 2.2e-16\r\n\r\nBetweenness\r\n\r\n\r\nShow code\r\n\r\nbetween_lm <- lm(ig_between~stat_between, data = gd_compare)\r\nsummary(between_lm)\r\n\r\n\r\n\r\nCall:\r\nlm(formula = ig_between ~ stat_between, data = gd_compare)\r\n\r\nResiduals:\r\n    Min      1Q  Median      3Q     Max \r\n-7.2702  0.4472  0.6129  0.6129  4.8884 \r\n\r\nCoefficients:\r\n             Estimate Std. Error t value Pr(>|t|)    \r\n(Intercept)  -0.61294    0.51241  -1.196    0.244    \r\nstat_between  1.05057    0.01668  62.977   <2e-16 ***\r\n---\r\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\r\n\r\nResidual standard error: 2.354 on 23 degrees of freedom\r\nMultiple R-squared:  0.9942,    Adjusted R-squared:  0.994 \r\nF-statistic:  3966 on 1 and 23 DF,  p-value: < 2.2e-16\r\n\r\nCloseness\r\n\r\n\r\nShow code\r\n\r\nclose_lm <- lm(ig_close~stat_close, data = gd_compare)\r\nsummary(close_lm)\r\n\r\n\r\n\r\nCall:\r\nlm(formula = ig_close ~ stat_close, data = gd_compare)\r\n\r\nResiduals:\r\n       Min         1Q     Median         3Q        Max \r\n-5.941e-10 -2.298e-10 -7.996e-11  2.380e-10  4.002e-10 \r\n\r\nCoefficients:\r\n             Estimate Std. Error   t value Pr(>|t|)    \r\n(Intercept) 1.453e-11  3.053e-10 4.800e-02    0.962    \r\nstat_close  4.167e-02  5.819e-10 7.161e+07   <2e-16 ***\r\n---\r\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\r\n\r\nResidual standard error: 2.918e-10 on 23 degrees of freedom\r\nMultiple R-squared:      1, Adjusted R-squared:      1 \r\nF-statistic: 5.127e+15 on 1 and 23 DF,  p-value: < 2.2e-16\r\n\r\nBonacich Power\r\n\r\n\r\nShow code\r\n\r\nbonpow_lm <- lm(ig_bonpow~stat_bonpow, data = gd_compare)\r\nsummary(bonpow_lm)\r\n\r\n\r\n\r\nCall:\r\nlm(formula = ig_bonpow ~ stat_bonpow, data = gd_compare)\r\n\r\nResiduals:\r\n    Min      1Q  Median      3Q     Max \r\n-1.2600 -0.4787 -0.1791  0.1350  2.3819 \r\n\r\nCoefficients:\r\n            Estimate Std. Error t value Pr(>|t|)  \r\n(Intercept)   0.6720     0.2827   2.377   0.0261 *\r\nstat_bonpow   0.6107     0.2827   2.160   0.0414 *\r\n---\r\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\r\n\r\nResidual standard error: 0.929 on 23 degrees of freedom\r\nMultiple R-squared:  0.1687,    Adjusted R-squared:  0.1326 \r\nF-statistic: 4.667 on 1 and 23 DF,  p-value: 0.0414\r\n\r\nEvaluation\r\nThere is high, nearly perfect in some cases, correlation in the\r\nscores given by the igraph and statnet packages in most measures. The\r\nlargest differences are in the Bonacich power scores. The other\r\ndifference, and most significant for my purposes, is the degree\r\ncentrality scores. Although they are statistically correlated to a high\r\ndegree, I have no independent way to verify which evaluation is\r\n“correct”, so I will go forward using both networks depending on the\r\nneeds of the task and capabilities of the packages.\r\nStructural Equivalence\r\nCreating the matrix element then taking a look at the summary using\r\nthe equivalence function “sedist”, the default measure of assessing the\r\napproximate structural equivalence of actors, or “complete”.\r\n“Complete”\r\n\r\n\r\nShow code\r\n\r\n#calculate equivalence from specified distance marix\r\ngd_stat_se<-equiv.clust(gd_statnet, equiv.fun=\"sedist\", method=\"hamming\",mode=\"graph\")\r\n\r\n\r\n\r\n\r\n\r\nShow code\r\n\r\n#summary of object produced by sedist()\r\n#summary(gd_stat_se)\r\n#plot equivalence clustering\r\nplot(gd_stat_se,labels=gd_stat_se$glabels)\r\n\r\n\r\n\r\n\r\nI need to look at the other methods of clustering as well.\r\n“Average”\r\n\r\n\r\nShow code\r\n\r\n#with average cluster.method\r\ngd_avg_se<-equiv.clust(gd_statnet, equiv.fun=\"sedist\", cluster.method=\"average\", method=\"hamming\",mode=\"graph\")\r\n#plot:\r\nplot(gd_avg_se,labels=gd_stat_se$glabels)\r\n\r\n\r\n\r\n\r\n“Single”\r\n\r\n\r\nShow code\r\n\r\n#with average cluster.method\r\ngd_sing_se<-equiv.clust(gd_statnet, equiv.fun=\"sedist\", cluster.method=\"single\", method=\"hamming\",mode=\"graph\")\r\n\r\n#plot:\r\nplot(gd_sing_se,labels=gd_stat_se$glabels)\r\n\r\n\r\n\r\n\r\n“Ward.D”\r\n\r\n\r\nShow code\r\n\r\n#with average cluster.method\r\ngd_wrd_se<-equiv.clust(gd_statnet, equiv.fun=\"sedist\", cluster.method=\"ward.D\", method=\"hamming\",mode=\"graph\")\r\n\r\n#plot:\r\nplot(gd_wrd_se,labels=gd_stat_se$glabels)\r\n\r\n\r\n\r\n\r\nPartition Using Clustering\r\nI understand that the number of partitions (or roles) will depend on\r\nthe height at which the dendrogram is cut. Using the tutorial example, I\r\nset the height at 15 and the result is 9 clusters. Using the alternate\r\nview from the tutorial, I also set the height at 10, and identify 10\r\ndistinct clusters.\r\nward.D, Height= 15\r\n\r\n\r\nShow code\r\n\r\n#plot equivalence clustering\r\nplot(gd_wrd_se,labels=gd_wrd_se$glabels)\r\n#partition the clusters\r\nrect.hclust(gd_wrd_se$cluster,h=15)\r\n\r\n\r\n\r\n\r\nward.D, Height= 10\r\n\r\n\r\nShow code\r\n\r\n#plot equivalence clustering\r\nplot(gd_wrd_se,labels=gd_wrd_se$glabels)\r\n#partition the clusters\r\nrect.hclust(gd_wrd_se$cluster,h=10)\r\n\r\n\r\n\r\n\r\nHeight= 20\r\nFor my own experimenting, looking at it with a higher height (“20”),\r\nit spreads the clusters to 5.\r\n\r\n\r\nShow code\r\n\r\n#plot equivalence clustering\r\nplot(gd_wrd_se,labels=gd_wrd_se$glabels)\r\n#partition the clusters\r\nrect.hclust(gd_wrd_se$cluster,h=20)\r\n\r\n\r\n\r\n\r\nBlockmodel Partitions\r\nInspecting the goodness of fit of the partitions that result from the\r\nclustering steps above using blockmodeling to try and get a better sense\r\nof how well the partitioning worked. Using the blockmodel command in\r\nstatnet and specifying “k=x” means that “x” will indicate how many\r\npartitions to create, and “h=x” means that “x” will indicate the height\r\nto cut the dendogram.\r\n2-partition blockmodel\r\n\r\n\r\nShow code\r\n\r\n#blockmodel and select partitions\r\nblk_mod<-blockmodel(gd_statnet,gd_wrd_se,k=2)\r\n#print blockmodel object\r\nblk_mod\r\n\r\n\r\n\r\nNetwork Blockmodel:\r\n\r\nBlock membership:\r\n\r\n  Eric Andersen     John Barlow     Bob Bralove  Andrew Charles \r\n              1               1               1               1 \r\n    John Dawson    Willie Dixon    Jerry Garcia  Donna Godchaux \r\n              1               1               2               2 \r\n Keith Godchaux   Gerrit Graham     Frank Guida     Mickey Hart \r\n              2               1               1               2 \r\n  Robert Hunter Bill Kreutzmann       Ned Lagin       Phil Lesh \r\n              2               2               1               2 \r\n     Peter Monk   Brent Mydland     Dave Parker Robert Petersen \r\n              1               1               2               1 \r\n         Pigpen     Joe Royster   Rob Wasserman        Bob Weir \r\n              2               1               1               2 \r\n  Vince Welnick \r\n              1 \r\n\r\nReduced form blockmodel:\r\n\r\n     Eric Andersen John Barlow Bob Bralove Andrew Charles John Dawson Willie Dixon Jerry Garcia Donna Godchaux Keith Godchaux Gerrit Graham Frank Guida Mickey Hart Robert Hunter Bill Kreutzmann Ned Lagin Phil Lesh Peter Monk Brent Mydland Dave Parker Robert Petersen Pigpen Joe Royster Rob Wasserman Bob Weir Vince Welnick \r\n           Block 1   Block 2\r\nBlock 1 0.07619048 0.1333333\r\nBlock 2 0.13333333 0.8222222\r\n\r\n\r\n\r\nShow code\r\n\r\nplot.block<-function(x=blk_mod, main=NULL, cex.lab=1){\r\n  plot.sociomatrix(x$blocked.data, labels=list(x$plabels,x$plabels),\r\n                   main=main, drawlines = FALSE, cex.lab=cex.lab)\r\n  for (j in 2:length(x$plabels)) if (x$block.membership[j] !=\r\n                                     x$block.membership[j-1]) \r\n    abline(v = j - 0.5, h = j - 0.5, lty = 3, xpd=FALSE)\r\n}\r\nplot.block(blk_mod,main=\"Grateful Dead Songwriting: 2 Partitions\", cex.lab=.4)\r\n\r\n\r\n\r\n\r\n5-partition blockmodel\r\n\r\n\r\nShow code\r\n\r\n#blockmodel and select partitions\r\nblk_mod2<-blockmodel(gd_statnet, gd_wrd_se,k=5)\r\n#print blockmodel object\r\nblk_mod2$block.model\r\n\r\n\r\n           Block 1    Block 2    Block 3   Block 4   Block 5\r\nBlock 1 0.04545455 0.05555556 0.04166667 0.4166667 0.4166667\r\nBlock 2 0.05555556 1.00000000 0.12500000 0.0000000 1.0000000\r\nBlock 3 0.04166667 0.12500000 0.71428571 1.0000000 1.0000000\r\nBlock 4 0.41666667 0.00000000 1.00000000       NaN 1.0000000\r\nBlock 5 0.41666667 1.00000000 1.00000000 1.0000000       NaN\r\n\r\nShow code\r\n\r\n#plot blockmodel partitions\r\nplot.block(blk_mod2,main=\"Grateful Dead Songwriting, 5 Partitions\", cex.lab=.5)\r\n\r\n\r\n\r\n\r\nconcoR-Based Partitions\r\n\r\n\r\nShow code\r\n\r\nlibrary(concoR)\r\n#select partitions with concor\r\nconcoR::concor_hca(list(gd_projection), p=2)\r\n\r\n\r\n   block          vertex\r\n1      1   Eric Andersen\r\n2      1     John Barlow\r\n6      2     Bob Bralove\r\n10     3  Andrew Charles\r\n16     4     John Dawson\r\n7      2    Willie Dixon\r\n17     4    Jerry Garcia\r\n18     4  Donna Godchaux\r\n19     4  Keith Godchaux\r\n3      1   Gerrit Graham\r\n11     3     Frank Guida\r\n20     4     Mickey Hart\r\n21     4   Robert Hunter\r\n22     4 Bill Kreutzmann\r\n12     3       Ned Lagin\r\n23     4       Phil Lesh\r\n13     3      Peter Monk\r\n4      1   Brent Mydland\r\n24     4     Dave Parker\r\n14     3 Robert Petersen\r\n25     4          Pigpen\r\n15     3     Joe Royster\r\n8      2   Rob Wasserman\r\n5      1        Bob Weir\r\n9      2   Vince Welnick\r\n\r\n\r\n\r\nShow code\r\n\r\n#select partitions with concor\r\nblks<-concoR::concor_hca(list(gd_projection), p=2)\r\n#blockmodel with concor\r\nblk_mod <- blockmodel(gd_statnet, blks$block, plabels=blks$vertex) \r\n#plot blockmodel object\r\nplot.block(blk_mod,main=\"Grateful Dead Songwriting, concoR 4 Partitions\", cex.lab=.5)\r\n\r\n\r\n\r\n\r\nBlockmodeling Choice\r\nIn my semester assignment posts, I looked more deeply into the role\r\nand blockmodeling of the network. In the end I was able to find a model\r\nthat represents the network most intuitively - the optimized 5-partition\r\nblockmodel.\r\n\r\n\r\nShow code\r\n\r\n#select partitions with optimization\r\nblks3<-blockmodeling::optRandomParC(gd_projection, k=5, rep=10, approaches=\"ss\", blocks=\"com\")\r\n#blockmodel with optimized partition\r\nblk_mod3<-blockmodel(gd_projection, blks3$best$best1$clu, plabels=rownames(gd_projection)) \r\n#print blockmodel object\r\nblk_mod3$block.model\r\nplot.block(blk_mod3,main=\"Grateful Dead Songwriting, 5 Optimized Partitions\", cex.lab=.5)\r\n#I can assign \"block.membership\" as a vertex attribute to my 5-partition blockmodel for igraph\r\nV(gd_igraph)$role<-blk_mod3$block.membership[match(V(gd_igraph)$name,blk_mod3$plabels)]\r\n#and statnet\r\ngd_statnet%v%\"role\"<-blk_mod3$block.membership[match(gd_statnet%v%\"vertex.names\", blk_mod3$plabels)]\r\n#add to node dataframes\r\n#attach role to centrality dataframe to create nodes dataframe\r\ngd_stat_nodes$block <- blk_mod3$block.membership\r\ngd_ig_nodes$block <- blk_mod3$block.membership\r\n\r\n\r\n\r\nBlockmodel Visualization\r\nI can assign “block.membership” as a vertex attribute to my\r\n5-partition blockmodel, then use the role attribute to change the color\r\nof plotted nodes in a network plot.\r\nigraph\r\n\r\n\r\nShow code\r\n\r\n#plot(gd_igraph, layout=layout_with_kk, vertex.color=V(gd_igraph)$role)\r\n\r\n\r\n\r\n\r\nstatnet\r\n\r\n\r\nShow code\r\n\r\n#library(GGally)\r\n#GGally::ggnet2(gd_statnet,\r\n               #node.color=\"role\", \r\n               #node.size=degree(gd_statnet, gmode=\"graph\"),\r\n               #node.label = \"vertex.names\",\r\n               #node.alpha = .5)\r\n\r\n\r\n\r\n\r\nCommunity\r\nFast and Greedy Community\r\nThe method attempts to detect dense sub-graphs by optimizing\r\nmodularity scores on igraph networks that are un-directed. I’ll start\r\nwith inspecting the names that are part of the new object.\r\nSimplify Function\r\nThe fast and greedy function was giving me an error code of:\r\nError in cluster_fast_greedy(gd_network_ig):At\r\nfast_community.c:660: fast-greedy community finding works only\r\non graphs without multiple edges, Invalid value\r\nSome community sourcing of opinions led me to run the “simplify()”\r\nfunction to correct this. And it did, during my semester assignment. But\r\nnow, simplify() is simply not working. I’m not going too deep into this\r\nnow, because frankly this community was the least intuitive when I ran\r\nit previously.\r\n\r\n\r\nShow code\r\n\r\n#create simplified igraph network\r\nsimple_gd <- simplify(gd_igraph)\r\n#run fast_greedy clustering algorithm\r\n#fg_gd <- cluster_fast_greedy(simple_gd)\r\nis.simple(simple_gd)\r\n\r\n\r\n[1] FALSE\r\n\r\nWalktrap Community\r\nDetection and Plot\r\nThe walktrap community detection created one community containing all\r\nof the songwriters in the giant component. I will not plot this\r\ncommunity.\r\n\r\n\r\nShow code\r\n\r\n#Run clustering algorithm: walktrap\r\nwt_gd <- walktrap.community(gd_igraph)\r\n#Inspect community membership\r\nigraph::groups(wt_gd)\r\n\r\n\r\n$`1`\r\n [1] \"Eric Andersen\"   \"John Barlow\"     \"Bob Bralove\"    \r\n [4] \"Andrew Charles\"  \"John Dawson\"     \"Willie Dixon\"   \r\n [7] \"Jerry Garcia\"    \"Donna Godchaux\"  \"Keith Godchaux\" \r\n[10] \"Gerrit Graham\"   \"Frank Guida\"     \"Mickey Hart\"    \r\n[13] \"Robert Hunter\"   \"Bill Kreutzmann\" \"Ned Lagin\"      \r\n[16] \"Phil Lesh\"       \"Peter Monk\"      \"Brent Mydland\"  \r\n[19] \"Dave Parker\"     \"Robert Petersen\" \"Pigpen\"         \r\n[22] \"Joe Royster\"     \"Rob Wasserman\"   \"Bob Weir\"       \r\n[25] \"Vince Welnick\"  \r\n\r\nCollect & Compare\r\nModularity Scores\r\nSaving the scores for evaluation and later analysis; I will continue\r\nto add the other community modularity scores into this vector as I run\r\nthem.\r\n\r\n\r\nShow code\r\n\r\nmods<-c(walktrap=modularity(wt_gd))\r\nmods\r\n\r\n\r\n walktrap \r\n0.2483386 \r\n\r\nLeading Label\r\nPropagation Community Detection\r\nIn this evaluation, each of the nodes was indicated to be in its’ own\r\ncommunity. I will not plot this community.\r\n\r\n\r\nShow code\r\n\r\n#Run clustering algorithm: leading label\r\nlab_gd<-label.propagation.community(gd_igraph)\r\n#Inspect community membership\r\nigraph::groups(lab_gd)\r\n\r\n\r\n$`1`\r\n[1] \"Eric Andersen\"\r\n\r\n$`2`\r\n[1] \"John Barlow\"\r\n\r\n$`3`\r\n[1] \"Bob Bralove\"\r\n\r\n$`4`\r\n[1] \"Andrew Charles\"\r\n\r\n$`5`\r\n[1] \"John Dawson\"\r\n\r\n$`6`\r\n[1] \"Willie Dixon\"\r\n\r\n$`7`\r\n[1] \"Jerry Garcia\"\r\n\r\n$`8`\r\n[1] \"Donna Godchaux\"\r\n\r\n$`9`\r\n[1] \"Keith Godchaux\"\r\n\r\n$`10`\r\n[1] \"Gerrit Graham\"\r\n\r\n$`11`\r\n[1] \"Frank Guida\"\r\n\r\n$`12`\r\n[1] \"Mickey Hart\"\r\n\r\n$`13`\r\n[1] \"Robert Hunter\"\r\n\r\n$`14`\r\n[1] \"Bill Kreutzmann\"\r\n\r\n$`15`\r\n[1] \"Ned Lagin\"\r\n\r\n$`16`\r\n[1] \"Phil Lesh\"\r\n\r\n$`17`\r\n[1] \"Peter Monk\"\r\n\r\n$`18`\r\n[1] \"Brent Mydland\"\r\n\r\n$`19`\r\n[1] \"Dave Parker\"\r\n\r\n$`20`\r\n[1] \"Robert Petersen\"\r\n\r\n$`21`\r\n[1] \"Pigpen\"\r\n\r\n$`22`\r\n[1] \"Joe Royster\"\r\n\r\n$`23`\r\n[1] \"Rob Wasserman\"\r\n\r\n$`24`\r\n[1] \"Bob Weir\"\r\n\r\n$`25`\r\n[1] \"Vince Welnick\"\r\n\r\nShow code\r\n\r\n#collect modularity scores to compare\r\nmods<-c(mods, label=modularity(lab_gd))\r\n\r\n\r\n\r\nEdge Betweenness Community\r\nDetection\r\nAgain, each of the nodes was indicated to be in its’ own community. I\r\nwill not plot this community.\r\n\r\n\r\nShow code\r\n\r\n#Run clustering algorithm: edge betweenness\r\nedge_gd <- label.propagation.community(gd_igraph)\r\n#Inspect community membership\r\nigraph::groups(edge_gd)\r\n\r\n\r\n$`1`\r\n[1] \"Eric Andersen\"\r\n\r\n$`2`\r\n[1] \"John Barlow\"\r\n\r\n$`3`\r\n[1] \"Bob Bralove\"\r\n\r\n$`4`\r\n[1] \"Andrew Charles\"\r\n\r\n$`5`\r\n[1] \"John Dawson\"\r\n\r\n$`6`\r\n[1] \"Willie Dixon\"\r\n\r\n$`7`\r\n[1] \"Jerry Garcia\"\r\n\r\n$`8`\r\n[1] \"Donna Godchaux\"\r\n\r\n$`9`\r\n[1] \"Keith Godchaux\"\r\n\r\n$`10`\r\n[1] \"Gerrit Graham\"\r\n\r\n$`11`\r\n[1] \"Frank Guida\"\r\n\r\n$`12`\r\n[1] \"Mickey Hart\"\r\n\r\n$`13`\r\n[1] \"Robert Hunter\"\r\n\r\n$`14`\r\n[1] \"Bill Kreutzmann\"\r\n\r\n$`15`\r\n[1] \"Ned Lagin\"\r\n\r\n$`16`\r\n[1] \"Phil Lesh\"\r\n\r\n$`17`\r\n[1] \"Peter Monk\"\r\n\r\n$`18`\r\n[1] \"Brent Mydland\"\r\n\r\n$`19`\r\n[1] \"Dave Parker\"\r\n\r\n$`20`\r\n[1] \"Robert Petersen\"\r\n\r\n$`21`\r\n[1] \"Pigpen\"\r\n\r\n$`22`\r\n[1] \"Joe Royster\"\r\n\r\n$`23`\r\n[1] \"Rob Wasserman\"\r\n\r\n$`24`\r\n[1] \"Bob Weir\"\r\n\r\n$`25`\r\n[1] \"Vince Welnick\"\r\n\r\nShow code\r\n\r\n#collect modularity scores to compare\r\nmods<-c(mods, edge=modularity(edge_gd))\r\n\r\n\r\n\r\nEigenvector Community\r\nDetection\r\nThis method has created four communities to examine.\r\n\r\n\r\nShow code\r\n\r\n#Run clustering algorithm: leading eigenvector\r\neigen_gd <- leading.eigenvector.community(gd_igraph)\r\n#Inspect community membership\r\nigraph::groups(eigen_gd)\r\n\r\n\r\n$`1`\r\n[1] \"Eric Andersen\" \"John Barlow\"   \"Bob Bralove\"   \"Willie Dixon\" \r\n[5] \"Gerrit Graham\" \"Brent Mydland\" \"Rob Wasserman\" \"Bob Weir\"     \r\n[9] \"Vince Welnick\"\r\n\r\n$`2`\r\n[1] \"John Dawson\"   \"Jerry Garcia\"  \"Robert Hunter\"\r\n\r\n$`3`\r\n [1] \"Andrew Charles\"  \"Frank Guida\"     \"Bill Kreutzmann\"\r\n [4] \"Ned Lagin\"       \"Phil Lesh\"       \"Peter Monk\"     \r\n [7] \"Dave Parker\"     \"Robert Petersen\" \"Pigpen\"         \r\n[10] \"Joe Royster\"    \r\n\r\n$`4`\r\n[1] \"Donna Godchaux\" \"Keith Godchaux\" \"Mickey Hart\"   \r\n\r\nShow code\r\n\r\n#collect modularity scores to compare\r\nmods<-c(mods, eigen=modularity(eigen_gd))\r\n\r\n\r\n\r\nigraph colors the nodes by community\r\n\r\n\r\nShow code\r\n\r\n#plot network with community coloring\r\nplot(eigen_gd,gd_igraph)\r\n\r\n\r\n\r\n\r\nSpinglass Community\r\nDetection\r\nThis method has also created 4 communities to examine.\r\n\r\n\r\nShow code\r\n\r\n#Run clustering algorithm: spinglass\r\nspin_gd <- spinglass.community(gd_igraph)\r\n#Inspect community membership\r\nigraph::groups(spin_gd)\r\n\r\n\r\n$`1`\r\n[1] \"Frank Guida\" \"Dave Parker\" \"Pigpen\"      \"Joe Royster\"\r\n\r\n$`2`\r\n[1] \"Andrew Charles\"  \"Ned Lagin\"       \"Phil Lesh\"      \r\n[4] \"Peter Monk\"      \"Brent Mydland\"   \"Robert Petersen\"\r\n\r\n$`3`\r\n[1] \"John Dawson\"     \"Jerry Garcia\"    \"Donna Godchaux\" \r\n[4] \"Keith Godchaux\"  \"Mickey Hart\"     \"Robert Hunter\"  \r\n[7] \"Bill Kreutzmann\"\r\n\r\n$`4`\r\n[1] \"Eric Andersen\" \"John Barlow\"   \"Bob Bralove\"   \"Willie Dixon\" \r\n[5] \"Gerrit Graham\" \"Rob Wasserman\" \"Bob Weir\"      \"Vince Welnick\"\r\n\r\nShow code\r\n\r\n#collect modularity scores to compare\r\nmods<-c(mods, spin=modularity(spin_gd))\r\n\r\n\r\n\r\nAgain, igraph colors the nodes by community\r\n\r\n\r\nShow code\r\n\r\n#plot network with community coloring\r\nplot(spin_gd,gd_igraph)\r\n\r\n\r\n\r\n\r\nCompare\r\nCommunity Partitions - Eigenvector and Spinglass\r\nIt would be worth comparing these scores on a weighted network in the\r\nfuture since it would take that into consideration. For now, I’m going\r\nto compare only the Eigenvector and Spinglass since those are the two\r\ncommunity models that produced actual divisions.\r\n\r\n\r\nShow code\r\n\r\n#compare community partition modularity scores\r\nmodularity(eigen_gd)\r\n\r\n\r\n[1] 0.4516602\r\n\r\n\r\n\r\nShow code\r\n\r\n#compare community partition modularity scores\r\nmodularity(spin_gd)\r\n\r\n\r\n[1] 0.04933856\r\n\r\nVariation Method\r\n\r\n\r\nShow code\r\n\r\n#compare community partitions using variation of information\r\ncompare(eigen_gd,spin_gd,method=\"vi\")\r\n\r\n\r\n[1] 0.8922415\r\n\r\nNormalized Mutual\r\nInformation Method\r\n\r\n\r\nShow code\r\n\r\n#compare community partitions\r\ncompare(eigen_gd,spin_gd,method=\"nmi\")\r\n\r\n\r\n[1] 0.6568228\r\n\r\nSplit Join Distance Method\r\n\r\n\r\nShow code\r\n\r\n#compare community partitions\r\ncompare(eigen_gd,spin_gd,method=\"split.join\")\r\n\r\n\r\n[1] 11\r\n\r\nRand Index Method\r\n\r\n\r\nShow code\r\n\r\n#compare community partitions\r\ncompare(eigen_gd,spin_gd,method=\"rand\")\r\n\r\n\r\n[1] 0.81\r\n\r\nAdjusted Rand Index Method\r\n\r\n\r\nShow code\r\n\r\n#compare community partitions\r\ncompare(eigen_gd,spin_gd,method=\"adjusted.rand\")\r\n\r\n\r\n[1] 0.5103093\r\n\r\nLouvain Community Clustering\r\nOne method I did not explore in the semester assignment was the\r\nLouvain clustering method. This method gives 7 communities that are\r\nsomewhat unexpected, but give an interesting and valid perspective on\r\nthe membership. The modularity of this method is 0.455, just above the\r\nmodularity score of the eigenvector community modularity and very\r\ncompetitive as an option.\r\n\r\n\r\nShow code\r\n\r\nlouvain <- cluster_louvain(gd_igraph)\r\n#collect modularity scores to compare\r\nmods<-c(mods, louvain=modularity(louvain))\r\n#Inspect community membership\r\nigraph::groups(spin_gd)\r\n\r\n\r\n$`1`\r\n[1] \"Frank Guida\" \"Dave Parker\" \"Pigpen\"      \"Joe Royster\"\r\n\r\n$`2`\r\n[1] \"Andrew Charles\"  \"Ned Lagin\"       \"Phil Lesh\"      \r\n[4] \"Peter Monk\"      \"Brent Mydland\"   \"Robert Petersen\"\r\n\r\n$`3`\r\n[1] \"John Dawson\"     \"Jerry Garcia\"    \"Donna Godchaux\" \r\n[4] \"Keith Godchaux\"  \"Mickey Hart\"     \"Robert Hunter\"  \r\n[7] \"Bill Kreutzmann\"\r\n\r\n$`4`\r\n[1] \"Eric Andersen\" \"John Barlow\"   \"Bob Bralove\"   \"Willie Dixon\" \r\n[5] \"Gerrit Graham\" \"Rob Wasserman\" \"Bob Weir\"      \"Vince Welnick\"\r\n\r\nvisualizing the louvain community\r\n\r\n\r\nShow code\r\n\r\nplot(louvain,gd_igraph)\r\n\r\n\r\n\r\nShow code\r\n\r\nV(gd_igraph)$community <- louvain$membership\r\n\r\n\r\n\r\nConclusion\r\nOn inspection of the community structures created by each algorithm,\r\nI felt that the louvain community best represented the network. The\r\nmodularity scores of the communities confirm that this is a reasonable\r\nobservation. The higher modularity scores represent divisions with dense\r\nedge connections between the vertices within a community but sparse\r\nconnections between vertices in different communities.\r\nA better visualization of this network with community membership\r\n\r\n\r\nShow code\r\n\r\ncolrs <- adjustcolor( c(\"gray50\", \"tomato\", \"gold\", \"yellowgreen\", \"cornflowerblue\", \"orange\"), alpha=.6)\r\n\r\nplot(gd_igraph, vertex.color=colrs[V(gd_igraph)$community])\r\n\r\n\r\n\r\n\r\nEvaluation of Modularity\r\nI am going to create a data frame to save with the modularity\r\nscores\r\n\r\n\r\nShow code\r\n\r\ngd_modularity <- c(mods)\r\ngd_modularity <- as.data.frame(gd_modularity)\r\nwrite.csv(gd_modularity, file = \"gd_modularity.csv\")\r\n\r\n\r\n\r\nFurther Analysis\r\nCommunity Membership\r\nNow that I have a community membership model that makes sense, I’ll\r\nsave it in the node data frames.\r\n\r\n\r\nShow code\r\n\r\nmembership <- louvain$membership\r\nmembership\r\n\r\n\r\n [1] 1 1 2 3 4 2 4 5 5 1 6 5 4 3 3 3 3 1 3 3 3 6 2 1 2\r\n\r\nShow code\r\n\r\n#adding to the gd_nodes\r\ngd_ig_nodes$louvain<-membership\r\ngd_stat_nodes$louvain<-membership\r\n\r\n\r\n\r\nK-core Decomposition\r\nFinding the k-core where every node has degree of at least “k”. I\r\nwill add this so my node data frames before finishing up so I have that\r\nbasic measure for furter analysis.\r\n\r\n\r\nShow code\r\n\r\nkc <- coreness(gd_igraph, mode=\"all\")\r\nkc\r\n\r\n\r\n  Eric Andersen     John Barlow     Bob Bralove  Andrew Charles \r\n              3              73              12               3 \r\n    John Dawson    Willie Dixon    Jerry Garcia  Donna Godchaux \r\n              4               4             264              12 \r\n Keith Godchaux   Gerrit Graham     Frank Guida     Mickey Hart \r\n             15               3               4              34 \r\n  Robert Hunter Bill Kreutzmann       Ned Lagin       Phil Lesh \r\n            264              92               3             110 \r\n     Peter Monk   Brent Mydland     Dave Parker Robert Petersen \r\n              3              40               7              13 \r\n         Pigpen     Joe Royster   Rob Wasserman        Bob Weir \r\n             92               4               9             135 \r\n  Vince Welnick \r\n             12 \r\n\r\nShow code\r\n\r\n#adding to the gd_nodes\r\ngd_ig_nodes$kcore<-kc\r\ngd_stat_nodes$kcore<-kc\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/igraph-analysis/ward_d.png",
    "last_modified": "2022-05-10T20:42:33-04:00",
    "input_file": {},
    "preview_width": 700,
    "preview_height": 432
  },
  {
    "path": "posts/gd-network-creation-statnet/",
    "title": "Grateful Network Creation: Statnet",
    "description": "Building a Grateful Dead Original Song Co-Writing Network in R using the Statnet Package",
    "author": [
      {
        "name": "Kristina Becvar",
        "url": "http://gratefulnetwork.live/"
      }
    ],
    "date": "2022-04-21",
    "categories": [
      "network creation",
      "network analytics",
      "network visualization",
      "statnet"
    ],
    "contents": "\r\n\r\nContents\r\nLoad Network Data\r\nAffiliation Matrix\r\nBipartite Projection\r\n\r\nStatnet Network\r\nNetwork Features\r\nVisualization\r\n\r\nDyad & Triad Census\r\nTransitivity\r\nGeodesic Distance\r\nComponents\r\nDensity\r\n\r\nCentrality\r\nTotal Centrality\r\nEigenvector Centrality\r\nCloseness\r\nBetweenness\r\nBonacich Power\r\nAdd as Attributes\r\n\r\nCorrelations of\r\nCentrality Measures\r\n\r\n\r\n\r\n\r\nShow code\r\n\r\nlibrary(ggplot2) \r\nlibrary(readr) \r\nlibrary(statnet)\r\nlibrary(ggraph)\r\nlibrary(tidyverse)\r\nlibrary(ergm)\r\nlibrary(dplyr)\r\nlibrary(corrr)\r\nlibrary(magrittr)\r\nsuppressWarnings(expr)\r\n\r\n\r\n\r\nLoad Network Data\r\nAffiliation Matrix\r\nLoading the dataset and creating the network to begin my\r\nanalysis:\r\n\r\n\r\nShow code\r\n\r\ngd_affiliation <- read.csv('gd_affiliation_matrix.csv', row.names = 1, header = TRUE, check.names = FALSE)\r\ngd_matrix <- as.matrix(gd_affiliation)\r\n\r\n\r\n\r\nInspecting the first 8 columns of the data structure in the\r\naffiliation matrix format:\r\n\r\n\r\nShow code\r\n\r\ndim(gd_matrix)\r\n\r\n\r\n[1]  25 181\r\n\r\nShow code\r\n\r\ngd_matrix[1:10, 1:4]\r\n\r\n\r\n               Alabama Getaway Alice D Millionaire Alligator Althea\r\nEric Andersen                0                   0         0      0\r\nJohn Barlow                  0                   0         0      0\r\nBob Bralove                  0                   0         0      0\r\nAndrew Charles               0                   0         0      0\r\nJohn Dawson                  0                   0         0      0\r\nWillie Dixon                 0                   0         0      0\r\nJerry Garcia                 1                   1         0      1\r\nDonna Godchaux               0                   0         0      0\r\nKeith Godchaux               0                   0         0      0\r\nGerrit Graham                0                   0         0      0\r\n\r\nBipartite Projection\r\nNow I can create the single mode network and examine the bipartite\r\nprojection. After converting the matrix to a square adjacency matrix, I\r\ncan look at the full matrix.\r\nI can also call the adjacency matrix count for co-writing incidences\r\nbetween certain songwriters, such as between writing partners Jerry\r\nGarcia and Robert Hunter (78) and between John Barlow and Bob Weir\r\n(21).\r\n\r\n\r\nShow code\r\n\r\ngd_projection <- gd_matrix%*%t(gd_matrix)\r\ndim(gd_projection)\r\n\r\n\r\n[1] 25 25\r\n\r\nShow code\r\n\r\ngd_projection[1:10, 1:4]\r\n\r\n\r\n               Eric Andersen John Barlow Bob Bralove Andrew Charles\r\nEric Andersen              1           0           0              0\r\nJohn Barlow                0          26           1              0\r\nBob Bralove                0           1           3              0\r\nAndrew Charles             0           0           0              1\r\nJohn Dawson                0           0           0              0\r\nWillie Dixon               0           0           0              0\r\nJerry Garcia               0           0           0              0\r\nDonna Godchaux             0           0           0              0\r\nKeith Godchaux             0           0           0              0\r\nGerrit Graham              0           0           0              0\r\n\r\nShow code\r\n\r\ngd_projection[\"Jerry Garcia\", \"Robert Hunter\"]\r\n\r\n\r\n[1] 78\r\n\r\nShow code\r\n\r\ngd_projection[\"John Barlow\", \"Bob Weir\"]\r\n\r\n\r\n[1] 21\r\n\r\nStatnet Network\r\nCoercing directly from the original affiliation matrix kept giving\r\nthe error, “Error: loops is FALSE, but\r\nx contains loops.”, even when I give the appropriate\r\narguments. I tried using the “intergraph” package to convert the network\r\nobject created in igraph, but it cannot coerce bipartite igraph\r\nnetworks.\r\n\r\nAfter the bipartite projection, I was able to create the statnet\r\nnetwork object.\r\n\r\n\r\nShow code\r\n\r\nset.seed(11)\r\ngd_statnet <- as.network(gd_projection,\r\n               directed = FALSE, \r\n               bipartite = FALSE,\r\n               loops = FALSE,\r\n               connected = FALSE)\r\n\r\n\r\n\r\nNetwork Features\r\nLooking at the features of the statnet network with the appropriate\r\ncommands\r\n\r\n\r\nShow code\r\n\r\nprint(gd_statnet)\r\n\r\n\r\n Network attributes:\r\n  vertices = 25 \r\n  directed = FALSE \r\n  hyper = FALSE \r\n  loops = FALSE \r\n  multiple = FALSE \r\n  bipartite = FALSE \r\n  total edges= 65 \r\n    missing edges= 0 \r\n    non-missing edges= 65 \r\n\r\n Vertex attribute names: \r\n    vertex.names \r\n\r\nNo edge attributes\r\n\r\nShow code\r\n\r\nnetwork::list.vertex.attributes(gd_statnet)\r\n\r\n\r\n[1] \"na\"           \"vertex.names\"\r\n\r\nShow code\r\n\r\nnetwork::list.edge.attributes(gd_statnet)\r\n\r\n\r\n[1] \"na\"\r\n\r\nShow code\r\n\r\ngd_statnet\r\n\r\n\r\n Network attributes:\r\n  vertices = 25 \r\n  directed = FALSE \r\n  hyper = FALSE \r\n  loops = FALSE \r\n  multiple = FALSE \r\n  bipartite = FALSE \r\n  total edges= 65 \r\n    missing edges= 0 \r\n    non-missing edges= 65 \r\n\r\n Vertex attribute names: \r\n    vertex.names \r\n\r\nNo edge attributes\r\n\r\nVisualization\r\nAnd a first look at the basic network structure\r\n\r\n\r\nShow code\r\n\r\nplot(gd_statnet)\r\n\r\n\r\n\r\n\r\nDyad & Triad Census\r\nLooking at the dyad/triad census info, I have a total of 2600 triads,\r\nwhich is in line with the results I got in igraph as well.\r\n\r\n\r\nShow code\r\n\r\nsna::dyad.census(gd_statnet)\r\n\r\n\r\n     Mut Asym Null\r\n[1,]  65    0  235\r\n\r\nShow code\r\n\r\nsna::triad.census(gd_statnet)\r\n\r\n\r\n      003 012 102 021D 021U 021C 111D 111U 030T 030C 201 120D 120U\r\n[1,] 1216   0 760    0    0    0    0    0    0    0 237    0    0\r\n     120C 210 300\r\n[1,]    0   0  87\r\n\r\nShow code\r\n\r\nsum(triad.census(gd_statnet))\r\n\r\n\r\n[1] 2300\r\n\r\nTransitivity\r\nLooking next at the network transitivity, I can confirm that it is\r\nthe same as the igraph network transitivity score of 0.5241.\r\n\r\n\r\nShow code\r\n\r\ngtrans(gd_statnet)\r\n\r\n\r\n[1] 0.5240964\r\n\r\nGeodesic Distance\r\nLooking at the geodesic distance tells me that on average, I can\r\nconfirm that the path length in statnet is 1.93, which is not\r\nsignificantly different than result from igraph of 2.01.\r\n\r\n\r\nShow code\r\n\r\ngd_gd <- geodist(gd_statnet,na.omit = TRUE, ignore.eval = TRUE, inf.replace = 0)\r\nmean(gd_gd$gdist)\r\n\r\n\r\n[1] 1.9296\r\n\r\nComponents\r\nI can determine that there is one component in the statnet network\r\nobject, as in igraph - 25 songwriters in the giant component and no\r\nisolates.\r\n\r\n\r\nShow code\r\n\r\ncomponents(gd_statnet)\r\n\r\n\r\n[1] 1\r\n\r\nDensity\r\nIn this case, the statnet output is far different from the igraph\r\noutput of ~2.1, so I am not sure what is happening with this aspect of\r\nthe calculation.\r\n\r\n\r\nShow code\r\n\r\nnetwork.density(gd_statnet)\r\n\r\n\r\n[1] 0.2166667\r\n\r\nCentrality\r\nTotal Centrality\r\nCalculating the total centrality degree as well as the “in-degree\r\ncentrality” and “out-degree centrality” clearly uses a different scale\r\nthan igraph.\r\n\r\n\r\nShow code\r\n\r\ngd_stat_nodes <- data.frame(name=gd_statnet%v%\"vertex.names\",\r\n    totdegree=sna::degree(gd_statnet),\r\n    indegree=sna::degree(gd_statnet, cmode=\"indegree\"),\r\n    outdegree=sna::degree(gd_statnet, cmode=\"outdegree\"))\r\nrescaled_degree <- degree(gd_statnet, g=1, gmode=\"graph\", \r\n        diag=FALSE, tmaxdev=FALSE, \r\n        cmode=\"freeman\", rescale=TRUE)\r\ngd_stat_nodes$rescaled <- rescaled_degree\r\n#sort the top total degree of nodes in the stat network\r\narrange(gd_stat_nodes, desc(totdegree))%>%slice(1:5)\r\n\r\n\r\n             name totdegree indegree outdegree   rescaled\r\n1        Bob Weir        34       17        17 0.13076923\r\n2       Phil Lesh        28       14        14 0.10769231\r\n3   Robert Hunter        22       11        11 0.08461538\r\n4    Jerry Garcia        20       10        10 0.07692308\r\n5 Bill Kreutzmann        18        9         9 0.06923077\r\n\r\nThe statnet total degree scores are again, very different from\r\nigraph. In igraph, Jerry Garcia is the highest degree node, which gels\r\nwith my hypothesis given his position as the practical and figurative\r\nhead of the band and the fact that he contributed to more songs than any\r\nother songwriter.\r\nHowever, more surprising than Jerry Garcia’s position in fourth in\r\nhighest total degree centrality is his songwriting partner Robert\r\nHunter’s position above him in third highest.\r\nI can understand how Bob Weir has a high centrality despite lower\r\nsong counts given his high Eigenvector centrality and betweenness status\r\nin previous igraph evaluations. However, I am surprised by his position\r\nas highest total degree and even more surprised that Phil Lesh is second\r\nhighest total degree centrality overall. Both are co-founding members of\r\nthe band, and did contribute to many songs written by the band, but not\r\nmore than Jerry Garcia. It does not make sense to me, knowing the\r\ncontext and subject matter, that they are ranked higher than Jerry\r\nGarcia.\r\nEigenvector Centrality\r\n\r\n\r\nShow code\r\n\r\n#calculate eigenvector centrality\r\neigen <- sna::evcent(gd_statnet, gmode=\"graph\")\r\n#add to nodes data frame\r\ngd_stat_nodes$eigenvector <- eigen\r\n\r\ngd_adjacency <- as.matrix(gd_statnet)\r\ngd_adjacency_2 <- gd_adjacency %*% gd_adjacency\r\n\r\n#calculate portion of reflected centrality\r\ngd_reflective <- diag(as.matrix(gd_adjacency_2))/rowSums(as.matrix(gd_adjacency_2))\r\ngd_reflective <- ifelse(is.nan(gd_reflective),0,gd_reflective)\r\n\r\n#calculate derived centrality\r\ngd_derived <- 1-diag(as.matrix(gd_adjacency_2))/rowSums(as.matrix(gd_adjacency_2))\r\ngd_derived <- ifelse(is.nan(gd_derived),1,gd_derived)\r\n\r\n#add to nodes data frame\r\ngd_stat_nodes$eigen_derived <- gd_derived\r\ngd_stat_nodes$eigen_reflective <- gd_reflective\r\n\r\n#sort the top total degree of nodes in the stat network\r\narrange(gd_stat_nodes, desc(eigenvector))%>%slice(1:5)\r\n\r\n\r\n             name totdegree indegree outdegree   rescaled eigenvector\r\n1        Bob Weir        34       17        17 0.13076923   0.4003206\r\n2       Phil Lesh        28       14        14 0.10769231   0.3539098\r\n3    Jerry Garcia        20       10        10 0.07692308   0.3305871\r\n4   Robert Hunter        22       11        11 0.08461538   0.3233581\r\n5 Bill Kreutzmann        18        9         9 0.06923077   0.3219131\r\n  eigen_derived eigen_reflective\r\n1     0.8333333        0.1666667\r\n2     0.8426966        0.1573034\r\n3     0.8837209        0.1162791\r\n4     0.8750000        0.1250000\r\n5     0.8941176        0.1058824\r\n\r\nThe most immediate observations I have, is that the highest degree\r\nnode in the igraph network, Jerry Garcia, was not the highest\r\nEigenvector centrality - but in this network Bob Weir is highest both in\r\ndegree and in Eigenvector centrality. The only change in the top five is\r\nthat Jerry Garcia moved ahead of Robert Hunter, which makes sense.\r\nThe derived and reflective scores do not make sense - I’m not sure\r\nthat the formula I used on the igraph network translates to statnet.\r\nCloseness\r\n\r\n\r\nShow code\r\n\r\n#calculate closeness\r\nclose <- closeness(gd_statnet, gmode=\"graph\")\r\n#add to nodes data frame\r\ngd_stat_nodes$closeness <- close\r\n#sort the top total degree of nodes in the stat network\r\narrange(gd_stat_nodes, desc(closeness))%>%slice(1:5)\r\n\r\n\r\n             name totdegree indegree outdegree   rescaled eigenvector\r\n1        Bob Weir        34       17        17 0.13076923   0.4003206\r\n2       Phil Lesh        28       14        14 0.10769231   0.3539098\r\n3   Robert Hunter        22       11        11 0.08461538   0.3233581\r\n4    Jerry Garcia        20       10        10 0.07692308   0.3305871\r\n5 Bill Kreutzmann        18        9         9 0.06923077   0.3219131\r\n  eigen_derived eigen_reflective closeness\r\n1     0.8333333        0.1666667 0.7741935\r\n2     0.8426966        0.1573034 0.7058824\r\n3     0.8750000        0.1250000 0.6486486\r\n4     0.8837209        0.1162791 0.6315789\r\n5     0.8941176        0.1058824 0.6153846\r\n\r\nThe closeness scores are similar to overall degree centrality, at\r\nleast in the top scores, and these are also in line with the igraph\r\nresults.\r\nBetweenness\r\n\r\n\r\nShow code\r\n\r\n#calculate betweenness\r\nbetween <- sna::betweenness(gd_statnet, gmode=\"graph\")\r\n#add to nodes data frame\r\ngd_stat_nodes$betweenness <- between\r\n#sort the top total degree of nodes in the stat network\r\narrange(gd_stat_nodes, desc(betweenness))%>%slice(1:5)\r\n\r\n\r\n           name totdegree indegree outdegree   rescaled eigenvector\r\n1      Bob Weir        34       17        17 0.13076923   0.4003206\r\n2     Phil Lesh        28       14        14 0.10769231   0.3539098\r\n3        Pigpen        16        8         8 0.06153846   0.2438925\r\n4 Robert Hunter        22       11        11 0.08461538   0.3233581\r\n5  Jerry Garcia        20       10        10 0.07692308   0.3305871\r\n  eigen_derived eigen_reflective closeness betweenness\r\n1     0.8333333        0.1666667 0.7741935   111.73333\r\n2     0.8426966        0.1573034 0.7058824    89.40000\r\n3     0.8857143        0.1142857 0.6000000    44.20000\r\n4     0.8750000        0.1250000 0.6486486    30.45000\r\n5     0.8837209        0.1162791 0.6315789    13.23333\r\n\r\nAgain, when comparing these results to the igraph results, the\r\nhighest degree node (Jerry Garcia) was not the node with the highest\r\nscoring betweenness. In the statnet network, the highest degree node,\r\nBob Weir, is also the highest betweenness score, and by a significantly\r\nsimilar ratio to Garcia as in the igraph network evaluation.\r\nSimilarly to igraph, Pigpen jumps up in the rankings for betweenness,\r\nlikely because his contributions were primarily full-band\r\ncompositions.\r\nBonacich Power\r\n\r\n\r\nShow code\r\n\r\n#calculate bonacich power\r\nbonpow <- sna::bonpow(gd_statnet, gmode=\"graph\")\r\n#add to nodes data frame\r\ngd_stat_nodes$bonacich <- bonpow\r\n#sort the top total degree of nodes in the stat network\r\narrange(gd_stat_nodes, desc(bonacich))%>%slice(1:5)\r\n\r\n\r\n            name totdegree indegree outdegree    rescaled eigenvector\r\n1 Donna Godchaux        12        6         6 0.046153846  0.23834221\r\n2   Willie Dixon         4        2         2 0.015384615  0.06423801\r\n3  Eric Andersen         2        1         1 0.007692308  0.04883644\r\n4  Gerrit Graham         2        1         1 0.007692308  0.04883644\r\n5    Joe Royster         4        2         2 0.015384615  0.03388727\r\n  eigen_derived eigen_reflective closeness betweenness    bonacich\r\n1     0.9062500       0.09375000 0.5454545           0  0.29459882\r\n2     0.9090909       0.09090909 0.4528302           0  0.26898153\r\n3     0.9411765       0.05882353 0.4444444           0  0.02561729\r\n4     0.9411765       0.05882353 0.4444444           0  0.02561729\r\n5     0.8000000       0.20000000 0.3870968           0 -0.07044754\r\n\r\nShow code\r\n\r\nwrite.csv(gd_stat_nodes, file = \"gd_stat_nodes.csv\")\r\n\r\n\r\n\r\nAdd as Attributes\r\n\r\n\r\nShow code\r\n\r\ngd_statnet %v% \"degree\"<- degree(gd_statnet)       # Degree centrality\r\ngd_statnet %v% \"eigenvector\"<- evcent(gd_statnet)       # Eigenvector centrality\r\ngd_statnet %v% \"closeness\"<- closeness(gd_statnet)    # Closeness centrality\r\ngd_statnet %v% \"betweenness\"<- betweenness(gd_statnet)  # Vertex betweenness centrality\r\ngd_statnet %v% \"bonacich\"<- bonpow(gd_statnet) # Bonacich power\r\n\r\n\r\n\r\nCorrelations of Centrality\r\nMeasures\r\n\r\n\r\nShow code\r\n\r\ncorrelations <- gd_stat_nodes %>% \r\n  select(totdegree,eigenvector,betweenness,closeness,bonacich)%>%\r\n  correlate() %>%\r\n  rearrange()\r\nfashion(correlations)\r\n\r\n\r\n         term closeness totdegree eigenvector betweenness bonacich\r\n1   closeness                 .97         .96         .79     -.36\r\n2   totdegree       .97                   .95         .83     -.32\r\n3 eigenvector       .96       .95                     .65     -.28\r\n4 betweenness       .79       .83         .65                 -.25\r\n5    bonacich      -.36      -.32        -.28        -.25         \r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/gd-network-creation-statnet/network.png",
    "last_modified": "2022-05-10T01:40:20-04:00",
    "input_file": {},
    "preview_width": 10102,
    "preview_height": 8426
  },
  {
    "path": "posts/gd-network-creation/",
    "title": "Grateful Network Creation: igraph",
    "description": "Building a Grateful Dead Original Song Co-Writing Network in R Using the igraph Package",
    "author": [
      {
        "name": "Kristina Becvar",
        "url": "http://gratefulnetwork.live/"
      }
    ],
    "date": "2022-04-20",
    "categories": [
      "network creation",
      "network analytics",
      "network visualization",
      "igraph"
    ],
    "contents": "\r\n\r\nContents\r\nNetwork Details\r\nBackground\r\nAffiliation Matrix\r\nBipartite Projection\r\nigraph\r\n\r\nNetwork Analysis: igraph\r\nFrom Incidence Matrix\r\nFrom Adjacency\r\nMatrix (Bipartite Projection)\r\nTriad Check\r\nTransitivity\r\nGeodesic Distance\r\nComponents\r\nDensity\r\nDegree Measure\r\nSummary Statistics\r\nNetwork Visualizations\r\nCentrality Measures\r\n\r\n\r\n\r\nNetwork Details\r\nBackground\r\nFor my project, I am using the Grateful Dead song writers data set\r\nthat I used in this series of posts from my Social & Political\r\nNetworks course to examine the network features of the co-writers of\r\noriginal Grateful Dead songs.\r\nThe data set consists of the links between co-writers of songs played\r\nby the Grateful Dead over their 30-year touring career that I\r\ncompiled.\r\nThere are 25 songwriters that contributed to the songs played over\r\nthe course of the Grateful Dead history, resulting in 25 nodes in the\r\ndataset.\r\nThere are a total of 181 (updated and still under review!) unique\r\nsongs played in the course of their touring career, and the various\r\ncombinations of co-writing combinations are now represented in a binary\r\naffiliation matrix.\r\nI have considered using various measures as network weights, but in\r\nthe end they have all been attributes and not weights. Unless there is a\r\nnew metric that rises to the forefront of my analysis, this network will\r\ncontinue to begin analysis as an un-weighted, bipartite matrix.\r\n\r\n\r\n\r\nAffiliation Matrix\r\nLoading the dataset and creating the network to begin my\r\nanalysis:\r\n\r\n\r\nShow code\r\n\r\ngd_affiliation <- read.csv('gd_affiliation_matrix.csv', row.names = 1, header = TRUE, check.names = FALSE)\r\ngd_matrix <- as.matrix(gd_affiliation)\r\n\r\n\r\n\r\nInspecting the first 8 columns of the data structure in the\r\naffiliation matrix format:\r\n\r\n\r\nShow code\r\n\r\ndim(gd_matrix)\r\n\r\n\r\n[1]  25 181\r\n\r\nShow code\r\n\r\ngd_matrix[1:10, 1:4]\r\n\r\n\r\n               Alabama Getaway Alice D Millionaire Alligator Althea\r\nEric Andersen                0                   0         0      0\r\nJohn Barlow                  0                   0         0      0\r\nBob Bralove                  0                   0         0      0\r\nAndrew Charles               0                   0         0      0\r\nJohn Dawson                  0                   0         0      0\r\nWillie Dixon                 0                   0         0      0\r\nJerry Garcia                 1                   1         0      1\r\nDonna Godchaux               0                   0         0      0\r\nKeith Godchaux               0                   0         0      0\r\nGerrit Graham                0                   0         0      0\r\n\r\nBipartite Projection\r\nNow I can create the single mode network and examine the bipartite\r\nprojection. After converting the matrix to a square adjacency matrix, I\r\ncan look at the full matrix.\r\nI can also call the adjacency matrix count for co-writing incidences\r\nbetween certain songwriters, such as between writing partners Jerry\r\nGarcia and Robert Hunter (78) and between John Barlow and Bob Weir\r\n(21).\r\n\r\n\r\nShow code\r\n\r\ngd_projection <- gd_matrix%*%t(gd_matrix)\r\ndim(gd_projection)\r\n\r\n\r\n[1] 25 25\r\n\r\nShow code\r\n\r\ngd_projection[1:10, 1:4]\r\n\r\n\r\n               Eric Andersen John Barlow Bob Bralove Andrew Charles\r\nEric Andersen              1           0           0              0\r\nJohn Barlow                0          26           1              0\r\nBob Bralove                0           1           3              0\r\nAndrew Charles             0           0           0              1\r\nJohn Dawson                0           0           0              0\r\nWillie Dixon               0           0           0              0\r\nJerry Garcia               0           0           0              0\r\nDonna Godchaux             0           0           0              0\r\nKeith Godchaux             0           0           0              0\r\nGerrit Graham              0           0           0              0\r\n\r\nShow code\r\n\r\ngd_projection[\"Jerry Garcia\", \"Robert Hunter\"]\r\n\r\n\r\n[1] 78\r\n\r\nShow code\r\n\r\ngd_projection[\"John Barlow\", \"Bob Weir\"]\r\n\r\n\r\n[1] 21\r\n\r\nigraph\r\nFrom Incidence Matrix\r\nConverting network data into igraph object using the\r\n“graph_from_incidence_matrix()” function gave me all songwriters and\r\nsongs as total vertices. Graphing after the bipartite projection allowed\r\na more accurate network.\r\n\r\n\r\nShow code\r\n\r\nset.seed(11)\r\ngd_igraph_from_im <- graph_from_incidence_matrix(gd_affiliation, directed = FALSE)\r\n\r\n\r\n\r\nFrom Adjacency Matrix\r\nConverting network data into igraph object using the\r\n“graph_from_incidence_matrix()” function gave me all songwriters and\r\nsongs as total vertices. Graphing after the bipartite projection allowed\r\na more accurate network.\r\n\r\n\r\nShow code\r\n\r\nset.seed(11)\r\ngd_igraph_adj <- graph.adjacency(gd_projection,mode=\"undirected\")\r\n\r\n\r\n\r\nNetwork Analysis: igraph\r\nNow to check the vertices in the graph I’ve created to ensure they\r\nrepresent the data accurately, and confirm that all of the attributes\r\nhave been represented properly (the graph is undirected, unweighted, and\r\nis bipartite):\r\nFrom Incidence Matrix\r\n\r\n\r\nhead(V(gd_igraph_from_im)$name)\r\n\r\n\r\n[1] \"Eric Andersen\"  \"John Barlow\"    \"Bob Bralove\"   \r\n[4] \"Andrew Charles\" \"John Dawson\"    \"Willie Dixon\"  \r\n\r\nhead(V(gd_igraph_from_im)$type)\r\n\r\n\r\n[1] FALSE FALSE FALSE FALSE FALSE FALSE\r\n\r\nis_directed(gd_igraph_from_im)\r\n\r\n\r\n[1] FALSE\r\n\r\nis_weighted(gd_igraph_from_im)\r\n\r\n\r\n[1] FALSE\r\n\r\nis_bipartite(gd_igraph_from_im)\r\n\r\n\r\n[1] TRUE\r\n\r\nigraph::vertex_attr_names(gd_igraph_from_im)\r\n\r\n\r\n[1] \"type\" \"name\"\r\n\r\nigraph::edge_attr_names(gd_igraph_from_im)\r\n\r\n\r\ncharacter(0)\r\n\r\nGraphing directly from the incidence matrix gives a bipartite\r\nnetwork, but when visualizing the network it is not clear if this is the\r\nway I want to represent this data.\r\n\r\n\r\nShow code\r\n\r\nplot(gd_igraph_from_im, layout=layout.bipartite)\r\n\r\n\r\n\r\n\r\nFrom Adjacency\r\nMatrix (Bipartite Projection)\r\n\r\n\r\nhead(V(gd_igraph_adj)$name)\r\n\r\n\r\n[1] \"Eric Andersen\"  \"John Barlow\"    \"Bob Bralove\"   \r\n[4] \"Andrew Charles\" \"John Dawson\"    \"Willie Dixon\"  \r\n\r\nhead(V(gd_igraph_adj)$type)\r\n\r\n\r\nNULL\r\n\r\nis_directed(gd_igraph_adj)\r\n\r\n\r\n[1] FALSE\r\n\r\nis_weighted(gd_igraph_adj)\r\n\r\n\r\n[1] FALSE\r\n\r\nis_bipartite(gd_igraph_adj)\r\n\r\n\r\n[1] FALSE\r\n\r\nigraph::vertex_attr_names(gd_igraph_adj)\r\n\r\n\r\n[1] \"name\"\r\n\r\nigraph::edge_attr_names(gd_igraph_adj)\r\n\r\n\r\ncharacter(0)\r\n\r\nGraphing from the bipartite projection and using the graph from\r\nadjacency matrix function, I have a network of the songwriters only, but\r\nI need to do more digging to see if this is the best way to represent\r\nthe data.\r\n\r\n\r\nShow code\r\n\r\nplot(gd_igraph_adj)\r\n\r\n\r\n\r\n\r\nTriad Check\r\nKnowing this network has 25 vertices, I want to see if the triad\r\ncensus is working correctly by comparing the following data:\r\n\r\n\r\nShow code\r\n\r\n#possible triads in network\r\n25*24*23/6\r\n\r\n\r\n[1] 2300\r\n\r\nShow code\r\n\r\nsum(igraph::triad.census(gd_igraph_from_im))\r\n\r\n\r\n[1] 1435820\r\n\r\nThe igraph created from the incidence matrix is NOT representing the\r\ntriad census properly.\r\n\r\n\r\nShow code\r\n\r\n#possible triads in network\r\n25*24*23/6\r\n\r\n\r\n[1] 2300\r\n\r\nShow code\r\n\r\nsum(igraph::triad.census(gd_igraph_adj))\r\n\r\n\r\n[1] 2300\r\n\r\nThe igraph network created from the adjacency matrix is representing\r\nthe triad census is working the way it should be.\r\nTransitivity\r\nLooking next at the global v. average local transitivity of the\r\nnetwork:\r\n\r\n\r\nShow code\r\n\r\n#get global clustering cofficient: igraph\r\ntransitivity(gd_igraph_from_im, type=\"global\")\r\n\r\n\r\n[1] 0\r\n\r\nShow code\r\n\r\n#get average local clustering coefficient: igraph\r\ntransitivity(gd_igraph_from_im, type=\"average\")\r\n\r\n\r\n[1] 0\r\n\r\nThis is another good sign that the correct choice is to graph from\r\nthe adjacency matrix throug the bipartite projection going forward.\r\n\r\n\r\nShow code\r\n\r\n#get global clustering cofficient: igraph\r\ntransitivity(gd_igraph_adj, type=\"global\")\r\n\r\n\r\n[1] 0.5240964\r\n\r\nShow code\r\n\r\n#get average local clustering coefficient: igraph\r\ntransitivity(gd_igraph_adj, type=\"average\")\r\n\r\n\r\n[1] 0.7755587\r\n\r\nThis transitivity tells me that the average network transitivity is\r\nsignificantly higher than the global transitivity, indicating, from my\r\nstill naive network knowledge, that the overall network is generally\r\nmore loose, and that there is a more connected sub-network.\r\nGeodesic Distance\r\nLooking at the geodesic distance tells me that on average, the path\r\nlength is just over 2.\r\n\r\n\r\nShow code\r\n\r\naverage.path.length(gd_igraph_adj,directed=F)\r\n\r\n\r\n[1] 2.01\r\n\r\nComponents\r\nGetting a look at the components of the network shows that there are\r\n2 components in the network, and 25 of the 26 nodes make up the giant\r\ncomponent with 1 isolate.\r\n\r\n\r\nShow code\r\n\r\nnames(igraph::components(gd_igraph_adj))\r\n\r\n\r\n[1] \"membership\" \"csize\"      \"no\"        \r\n\r\nShow code\r\n\r\nigraph::components(gd_igraph_adj)$no \r\n\r\n\r\n[1] 1\r\n\r\nShow code\r\n\r\nigraph::components(gd_igraph_adj)$csize\r\n\r\n\r\n[1] 25\r\n\r\nThis is a great start - now I can get to looking at the network\r\ndensity, centrality, and centralization.\r\nDensity\r\nThe network density measure: First with just the call “graph.density”\r\nand then with adding “loops=TRUE”. Since I’m using igraph, I know that\r\nits’ default output assumes that loops are not included but does not\r\nremove them, which can be corrected with the addition of “loops=TRUE”\r\nper the course tutorials when comparing output to statnet. This gives me\r\nconfidence that my network density is closer to 2.26.\r\n\r\n\r\nShow code\r\n\r\ngraph.density(gd_igraph_adj)\r\n\r\n\r\n[1] 2.453333\r\n\r\nShow code\r\n\r\ngraph.density(gd_igraph_adj, loops=TRUE)\r\n\r\n\r\n[1] 2.264615\r\n\r\nDegree Measure\r\nThe network degree measure: This gives me a clear output showing the\r\ndegree of each particular node (songwriter). I will also begin creating\r\na dataframe for easier review going forward.\r\nIt is not surprising, knowing my subject matter, that Jerry Garcia is\r\nthe highest degree node in this network as the practical and figurative\r\nhead of the band. The other band members’ degree measures are not\r\nnecessarily what I expected, though. I did not anticipate that his\r\nsongwriting partner and key collaborator, Robert Hunter, would have a\r\nhigher degree than band members Phil Lesh and Bob Weir. Further, I did\r\nnot anticipate that the degree measure of band member ‘Pigpen’ would be\r\nso high given his early death in the first years of the band’s touring\r\nlife. Specifically, I’m surprised that Pigpen has a higher degree than\r\nJohn Barlow, who was the key collaborator and writing partner of Bob\r\nWeir. This tells me that the proportion of songs that Weir wrote outside\r\nof the songs written with Barlow were much more dramatic than the\r\nproportion of songs Garcia wrote outside the songs written with\r\nHunter.\r\nThe original lineup of Jerry Garcia, Bob Weir, Phil Lesh, Bill\r\nKreutzmann, and Pigpen as well as Robert Hunter’s presence in the\r\nformative years of the band’s most collaborative era, means that this\r\ndegree ranking makes sense intuitively.\r\n\r\n\r\nShow code\r\n\r\ngd_ig_nodes<-data.frame(name=V(gd_igraph_adj)$name, degree=igraph::degree(gd_igraph_adj, loops = FALSE))\r\ngd_ig_nodes$normalized <-igraph::degree(gd_igraph_adj, loops = FALSE, normalized = TRUE)\r\n\r\ngd_ig_nodes%>%\r\n  arrange(desc(degree))\r\n\r\n\r\n                           name degree normalized\r\nJerry Garcia       Jerry Garcia    142 5.91666667\r\nRobert Hunter     Robert Hunter    117 4.87500000\r\nBob Weir               Bob Weir    105 4.37500000\r\nPhil Lesh             Phil Lesh     81 3.37500000\r\nBill Kreutzmann Bill Kreutzmann     62 2.58333333\r\nPigpen                   Pigpen     51 2.12500000\r\nJohn Barlow         John Barlow     29 1.20833333\r\nMickey Hart         Mickey Hart     18 0.75000000\r\nBrent Mydland     Brent Mydland     11 0.45833333\r\nKeith Godchaux   Keith Godchaux     10 0.41666667\r\nBob Bralove         Bob Bralove      8 0.33333333\r\nVince Welnick     Vince Welnick      7 0.29166667\r\nDonna Godchaux   Donna Godchaux      6 0.25000000\r\nRob Wasserman     Rob Wasserman      6 0.25000000\r\nDave Parker         Dave Parker      5 0.20833333\r\nRobert Petersen Robert Petersen      5 0.20833333\r\nJohn Dawson         John Dawson      2 0.08333333\r\nWillie Dixon       Willie Dixon      2 0.08333333\r\nFrank Guida         Frank Guida      2 0.08333333\r\nJoe Royster         Joe Royster      2 0.08333333\r\nEric Andersen     Eric Andersen      1 0.04166667\r\nAndrew Charles   Andrew Charles      1 0.04166667\r\nGerrit Graham     Gerrit Graham      1 0.04166667\r\nNed Lagin             Ned Lagin      1 0.04166667\r\nPeter Monk           Peter Monk      1 0.04166667\r\n\r\nSummary Statistics\r\nA quick look at the summary statistics confirms for me the minimum,\r\nmaximum, median, and mean node degree data.\r\n\r\n\r\nShow code\r\n\r\nsummary(gd_ig_nodes)\r\n\r\n\r\n     name               degree         normalized     \r\n Length:25          Min.   :  1.00   Min.   :0.04167  \r\n Class :character   1st Qu.:  2.00   1st Qu.:0.08333  \r\n Mode  :character   Median :  6.00   Median :0.25000  \r\n                    Mean   : 27.04   Mean   :1.12667  \r\n                    3rd Qu.: 29.00   3rd Qu.:1.20833  \r\n                    Max.   :142.00   Max.   :5.91667  \r\n\r\nNetwork Visualizations\r\nNow I want to take a step back and try to visually represent this\r\ndata better.\r\n\r\n\r\nShow code\r\n\r\n#ggraph(gd_igraph_adj, layout = \"fr\") +\r\n  #geom_edge_link() + \r\n  #geom_node_point(aes(color = factor(color))) + \r\n  #geom_node_text(aes(label = name), repel = TRUE) +\r\n  #theme_void() +\r\n  #theme(legend.position = \"none\") \r\n\r\n\r\n\r\n\r\nThat is starting to look more meaningful!\r\n\r\n\r\nShow code\r\n\r\n# Set size to degree centrality \r\n#V(gd_igraph_adj)$size = degree=igraph::degree(gd_igraph_adj)\r\n\r\n#Additional customisation for better legibility \r\n#ggraph(gd_igraph_adj, layout = \"fr\") +\r\n  #geom_edge_arc(strength = 0.2, width = 0.5, alpha = 0.15) + \r\n  #geom_node_point(aes(size = size, color = factor(color))) + \r\n  #geom_node_text(aes(label = name, size = size), repel = TRUE) +\r\n  #theme_void() +\r\n  #theme(legend.position = \"none\") \r\n\r\n\r\n\r\n\r\nCentrality Measures\r\nTo examine additional centrality and power scores of the nodes, I\r\nadded to the data frame with the centrality degree and normalized\r\ncentrality. Now I am adding Bonacich power, rescaled Bonacich power,\r\nEigenvector centrality scores and the breakdown of reflected and derived\r\ncentrality scores. Additionally, I am adding the closeness, betweenness,\r\nand Burt centrality scores.\r\nTo calculate the reflected and derived centrality scores, I first run\r\nsome operations on the adjacency matrix and keep in mind that these two\r\nscores make up the entire calculation of the Eigenvector centrality\r\nscore.\r\n\r\n\r\nShow code\r\n\r\n#gd_adjacency <- as.matrix(as_adjacency_matrix(gd_igraph_adj))\r\n#gd_adjacency_2 <- gd_adjacency %*% gd_adjacency\r\n\r\n#calculate Bonacich power\r\n#bp_ig1 <- power_centrality(gd_igraph_adj) #with a default index of \"1\"\r\n#bp_ig2 <- power_centrality(gd_igraph_adj, rescale = TRUE) #rescaled so they sum to \"1\"\r\n\r\n#calculate portion of reflected centrality\r\n#gd_reflective <- diag(as.matrix(gd_adjacency_2))/rowSums(as.matrix(gd_adjacency_2))\r\n#gd_reflective <- ifelse(is.nan(gd_reflective),0,gd_reflective)\r\n\r\n#calculate derived centrality\r\n#gd_derived <- 1-diag(as.matrix(gd_adjacency_2))/rowSums(as.matrix(gd_adjacency_2))\r\n#gd_derived <- ifelse(is.nan(gd_derived),1,gd_derived)\r\n\r\n#calculate closeness centrality: igraph\r\n#close <- igraph::closeness(gd_igraph_adj)\r\n\r\n#calculate betweenness centrality: igraph\r\n#between <- igraph::betweenness(gd_igraph_adj, directed=FALSE)\r\n\r\n#calculate Burt's network constraint\r\n#constraint <- constraint(gd_igraph_adj)\r\n\r\n#add these values to the data frame I started\r\n#gd_ig_nodes$eigenvector <- eigen\r\n#gd_ig_nodes$eigen_derived <- gd_derived\r\n#gd_ig_nodes$eigen_reflective <- gd_reflective\r\n#gd_ig_nodes$betweenness <- between\r\n#gd_ig_nodes$closeness <- close\r\n#gd_ig_nodes$bonacich <- bp_ig1\r\n#gd_ig_nodes$bonacich_rescaled <- bp_ig2\r\n#gd_ig_nodes$constraint <- constraint\r\n#options(scipen = 999)\r\n\r\ngd_ig_nodes<-read.csv(\"gd_ig_nodes.csv\")\r\nhead(gd_ig_nodes[2:7])\r\n\r\n\r\n            name degree normalized eigenvector eigen_derived\r\n1  Eric Andersen      1 0.04166667  0.04883644     0.9875776\r\n2    John Barlow     29 1.20833333  0.07763512     0.7648126\r\n3    Bob Bralove      8 0.33333333  0.12770600     0.9733796\r\n4 Andrew Charles      1 0.04166667  0.04317463     0.9829060\r\n5    John Dawson      2 0.08333333  0.07977694     0.9933775\r\n6   Willie Dixon      2 0.08333333  0.06423801     0.9823529\r\n  eigen_reflective\r\n1      0.012422360\r\n2      0.235187424\r\n3      0.026620370\r\n4      0.017094017\r\n5      0.006622517\r\n6      0.017647059\r\n\r\nEigenvector Centrality\r\nI am also interested in the Eigenvector centrality scores - Both the\r\ntop as well as the lowest value scores.\r\n\r\n\r\nShow code\r\n\r\ngd_ig_nodes%>%\r\n  arrange(desc(eigenvector))%>%\r\n  slice(1:5)\r\n\r\n\r\n                X            name degree normalized eigenvector\r\n1        Bob Weir        Bob Weir    105   4.375000   0.4003206\r\n2       Phil Lesh       Phil Lesh     81   3.375000   0.3539098\r\n3    Jerry Garcia    Jerry Garcia    142   5.916667   0.3305871\r\n4   Robert Hunter   Robert Hunter    117   4.875000   0.3233581\r\n5 Bill Kreutzmann Bill Kreutzmann     62   2.583333   0.3219131\r\n  eigen_derived eigen_reflective betweenness  closeness   bonacich\r\n1     0.7826043        0.2173957  121.659478 0.03225806 -0.5325373\r\n2     0.8536971        0.1463029   90.396640 0.02941176 -0.1771572\r\n3     0.6538547        0.3461453   16.584364 0.02631579 -0.2501870\r\n4     0.6286725        0.3713275   24.106816 0.02702703 -0.1701447\r\n5     0.8947211        0.1052789    3.132042 0.02564103 -0.6875388\r\n  bonacich_rescaled constraint\r\n1       -0.10060043  0.3367355\r\n2       -0.03346637  0.4521996\r\n3       -0.04726227  0.5061908\r\n4       -0.03214166  0.6332636\r\n5       -0.12988143  0.5159787\r\n\r\nBob Weir having top overall Eigenvector centrality makes sense - he\r\nis a core founding member and a prolific songwriter. He did not write as\r\nmany songs as Jerry Garcia or Robert Hunter, but he wrote with a larger\r\nvariety of people.\r\nThe top derived Eigenvector centrality scores are songwriters who\r\ncontributed to songs but were outside the band member or key\r\ncollaborator circle, which again makes sense.\r\nRobert Hunter having the top reflective Eigenvector centrality score\r\nis not a shock - he has long held the unofficial title of band member\r\nand as the person behind the songwriting magic of the Grateful Dead. His\r\nprimary songwriting partner was Jerry Garcia, but he also wrote songs\r\nwith the early, full band and later with almost all of the individual\r\nmembers of the band.\r\nCloseness\r\nThe closeness centrality of a node is defined as the sum of the\r\ngeodesic distances between that node and all other nodes in a\r\nnetwork.\r\n\r\n\r\nShow code\r\n\r\ngd_ig_nodes%>%\r\n  arrange(desc(closeness))%>%\r\n  slice(1:5)\r\n\r\n\r\n                X            name degree normalized eigenvector\r\n1        Bob Weir        Bob Weir    105   4.375000   0.4003206\r\n2       Phil Lesh       Phil Lesh     81   3.375000   0.3539098\r\n3   Robert Hunter   Robert Hunter    117   4.875000   0.3233581\r\n4    Jerry Garcia    Jerry Garcia    142   5.916667   0.3305871\r\n5 Bill Kreutzmann Bill Kreutzmann     62   2.583333   0.3219131\r\n  eigen_derived eigen_reflective betweenness  closeness   bonacich\r\n1     0.7826043        0.2173957  121.659478 0.03225806 -0.5325373\r\n2     0.8536971        0.1463029   90.396640 0.02941176 -0.1771572\r\n3     0.6286725        0.3713275   24.106816 0.02702703 -0.1701447\r\n4     0.6538547        0.3461453   16.584364 0.02631579 -0.2501870\r\n5     0.8947211        0.1052789    3.132042 0.02564103 -0.6875388\r\n  bonacich_rescaled constraint\r\n1       -0.10060043  0.3367355\r\n2       -0.03346637  0.4521996\r\n3       -0.03214166  0.6332636\r\n4       -0.04726227  0.5061908\r\n5       -0.12988143  0.5159787\r\n\r\nThis evaluation is more difficult as the range is made up of much\r\nsmaller scaled scores, but seem to be somewhat in line with the\r\nEigenvector centrality scores.\r\nIn addition to node-level centrality scores, I also want to calculate\r\nthe network level centralization index for closeness centrality\r\nmeasures. Here, I get a network level closeness measure of 0.552.\r\n\r\n\r\n#calculate closeness centralization index: igraph\r\ncentr_clo(gd_igraph_adj)$centralization\r\n\r\n\r\n[1] 0.5519071\r\n\r\nBetweenness\r\nBetweenness represents the number of geodesics on which a node\r\nsits.\r\nNow I want to take the closeness and betweenness to my centrality\r\ndata frame and first, sort by and take a look at the nodes with the\r\nhighest betweenness:\r\n\r\n\r\nShow code\r\n\r\ngd_ig_nodes%>%\r\n  arrange(desc(betweenness))%>%\r\n  slice(1:5)\r\n\r\n\r\n              X          name degree normalized eigenvector\r\n1      Bob Weir      Bob Weir    105   4.375000   0.4003206\r\n2     Phil Lesh     Phil Lesh     81   3.375000   0.3539098\r\n3        Pigpen        Pigpen     51   2.125000   0.2438925\r\n4 Robert Hunter Robert Hunter    117   4.875000   0.3233581\r\n5  Jerry Garcia  Jerry Garcia    142   5.916667   0.3305871\r\n  eigen_derived eigen_reflective betweenness  closeness   bonacich\r\n1     0.7826043        0.2173957   121.65948 0.03225806 -0.5325373\r\n2     0.8536971        0.1463029    90.39664 0.02941176 -0.1771572\r\n3     0.8868967        0.1131033    44.02857 0.02500000 -0.5155271\r\n4     0.6286725        0.3713275    24.10682 0.02702703 -0.1701447\r\n5     0.6538547        0.3461453    16.58436 0.02631579 -0.2501870\r\n  bonacich_rescaled constraint\r\n1       -0.10060043  0.3367355\r\n2       -0.03346637  0.4521996\r\n3       -0.09738708  0.5404552\r\n4       -0.03214166  0.6332636\r\n5       -0.04726227  0.5061908\r\n\r\nThe most immediate observations I have is that the highest degree\r\nnode (Jerry Garcia) is not the node with the highest scoring\r\nbetweenness. That goes to Bob Weir, who is still a relatively high\r\ndegree node, but significantly lower than Jerry Garcia given that his\r\nbetweenness score is so much higher (~121 compared to Garcia’s ~16).\r\nI can make a guess that the two highest degree nodes, Jerry Garcia\r\nand Robert Hunter, having relatively low betweenness scores can be\r\nlinked to the fact that the two wrote mostly together. Although the pair\r\nwrote the most songs in the originals catalog, Bob Weir wrote many songs\r\nwith a variety of other songwriters, as suspected by the results in the\r\ndegree scores. This would give him a higher level of betweenness.\r\nSimilarly, Phil Lesh and Pigpen, original band members who wrote\r\nrelatively fewer songs, contributed to more songs that were written by\r\nthe entire band, giving them more exposure to connections on the songs\r\nthat they did write.\r\nBonacich Power\r\nBonacich power is a bit complicated but I have taken away the concept\r\nthat it measures how powerful a node is based on the relative strength\r\nor weakness of their alters.\r\nThe lower, negative Bonacich power values imply that nodes become\r\nmore powerful as their alters become weaker; positive Bonacich power\r\nvalues imply that nodes becomemore powerful as their alters become more\r\npowerful.\r\nThe cooperative songwriting network is likely not going to be a good\r\nexample of this power compared to examining cooperative v. antagonistic\r\nrelationships.\r\n\r\n\r\nShow code\r\n\r\ngd_ig_nodes%>%\r\n  arrange(desc(bonacich))%>%\r\n  slice(1:5)\r\n\r\n\r\n                X            name degree normalized eigenvector\r\n1     Frank Guida     Frank Guida      2 0.08333333  0.03388727\r\n2     Joe Royster     Joe Royster      2 0.08333333  0.03388727\r\n3  Donna Godchaux  Donna Godchaux      6 0.25000000  0.23834221\r\n4  Keith Godchaux  Keith Godchaux     10 0.41666667  0.27350064\r\n5 Robert Petersen Robert Petersen      5 0.20833333  0.05639403\r\n  eigen_derived eigen_reflective betweenness  closeness bonacich\r\n1     0.9620253       0.03797468 0.000000000 0.01612903 3.010938\r\n2     0.9620253       0.03797468 0.000000000 0.01612903 3.010938\r\n3     0.9771689       0.02283105 0.000000000 0.02272727 1.206495\r\n4     0.9820014       0.01799856 0.009345794 0.02325581 1.157009\r\n5     0.9367816       0.06321839 0.000000000 0.01818182 1.096478\r\n  bonacich_rescaled constraint\r\n1         0.5687896  0.8224000\r\n2         0.5687896  0.8224000\r\n3         0.2279163  0.4514219\r\n4         0.2185680  0.5143887\r\n5         0.2071332  0.7134697\r\n\r\nNetwork Constraint (Burt)\r\nConstraint is a measure of the redundancy of a node’s connections. It\r\nis bound between 0 and 1, with 0 being a complete lack of restraint, and\r\n1 being complete redundancy.\r\n\r\n\r\nShow code\r\n\r\ngd_ig_nodes %>%\r\n  select(name,constraint)\r\n\r\n\r\n              name constraint\r\n1    Eric Andersen  1.0000000\r\n2      John Barlow  0.6706222\r\n3      Bob Bralove  0.4989170\r\n4   Andrew Charles  1.0000000\r\n5      John Dawson  1.2945238\r\n6     Willie Dixon  0.7040590\r\n7     Jerry Garcia  0.5061908\r\n8   Donna Godchaux  0.4514219\r\n9   Keith Godchaux  0.5143887\r\n10   Gerrit Graham  1.0000000\r\n11     Frank Guida  0.8224000\r\n12     Mickey Hart  0.5294014\r\n13   Robert Hunter  0.6332636\r\n14 Bill Kreutzmann  0.5159787\r\n15       Ned Lagin  1.0000000\r\n16       Phil Lesh  0.4521996\r\n17      Peter Monk  1.0000000\r\n18   Brent Mydland  0.9325133\r\n19     Dave Parker  0.5591083\r\n20 Robert Petersen  0.7134697\r\n21          Pigpen  0.5404552\r\n22     Joe Royster  0.8224000\r\n23   Rob Wasserman  0.4756234\r\n24        Bob Weir  0.3367355\r\n25   Vince Welnick  0.5216319\r\n\r\nSimilarly to the look at derived Eigenvector centrality, the highest\r\nnetwork constraint scores go to songwriters that were relatively\r\nisolated in their contributions. However, beyond that, the results are\r\nvery diverse in how they fall. The least constrained node, Bob Weir, is\r\nalso the highest Eigenvector value as well as highest in betweenness.\r\nBut second least constrained - Donna Godchaux - contributed to few\r\nsongs, but most of them full-band collaborations, does indicate to me\r\nmore of what this measure represents.\r\n\r\n\r\n\r\n",
    "preview": "posts/gd-network-creation/graph1.png",
    "last_modified": "2022-05-09T22:01:09-04:00",
    "input_file": {},
    "preview_width": 700,
    "preview_height": 432
  },
  {
    "path": "posts/welcome/",
    "title": "Welcome to the Grateful Network Project",
    "description": "Theory and Goals",
    "author": [
      {
        "name": "Kristina Becvar",
        "url": "https://kbec19.github.io/Grateful-Network/"
      }
    ],
    "date": "2022-03-25",
    "categories": [
      "grateful network",
      "summary"
    ],
    "contents": "\r\nIntroduction\r\n“The attempt to make sense of trying to make sense of something\r\nthat possibly makes no sense makes a sense of its own; a sense often\r\nmore akin to music than to reason.” —Robert Hunter, “A Note on Method,”\r\nA Strange Music, 1991 (Meriwether, 2012)\r\nDespite the words of key Grateful Dead collaborator and poet Robert\r\nHunter, I decided to tackle the task of analyzing the social network of\r\nsongwriters of the Grateful Dead’s original song catalog.\r\nMusic is a product of collective action, involving many participants\r\nwho interact and form various types of social tie with one another.\r\n(Crossley, 2008) A music world is a subset of the total musical activity\r\nin a society, and is also a social network because it is an activity\r\ninvolving interaction within and between artists, audiences, crew, and\r\noutside interests. (Crossley & Emms, 2016)\r\nThis research looks at songwriters as nodes, and ties where\r\ncollaborative relationships exist represent co-authorship of songs. This\r\nstructure, therefore, begins as an incidence matrix where songwriters\r\nand songs are represented in a matrix which is projected into a\r\nbipartite structure where co-affiliation is used as grounds that two\r\nactors (songwriters) are connected. Unfortunately, this projection also\r\nsimplifies the social structure of the network and omits some key\r\ninformation. For instance, in this simplified projection, there is\r\nlittle ability to look at where songwriters had external relationships,\r\nhow popular or resonant a song was. This is something I hope to explore\r\nin further studies.\r\nIn the collective production of music, there are perhaps three main\r\ncreative outputs, compositions - the songs that are written, recorded\r\nmusic and live performances. Watson, J. B. (2020) The live performances\r\nof the songs of the Grateful Dead are integral to their success, both in\r\nprojecting the success through playing the songs and - more importantly\r\n- reflecting the success through the demand for the songs from the\r\ncrowd. The Grateful Dead was a top-grossing touring act for years, but\r\nsaw much less success in the sale of their albums. (Gallo, 2001) It it\r\ntherefore plausible that further analysis of the strength of the\r\nsongwriting connections in their music should be analyzed along with\r\nsome measures of their resonance with the audience via how often a song\r\nwas played.\r\nAlternatively or complementary, it could be helpful to look at the\r\nroles live venues play in the frequency of a song’s live performance.\r\nTaking this attribute further could look like an analysis of headlining\r\ngigs compared with participation in festivals.\r\nFinally, another application of network modeling could be to look at\r\nhow these original songs were spread into the societal sub-culture\r\nthrough cover bands and covers by other iterations of bands containing\r\nmembers of the Grateful Dead. Conversely, expanding the network analysis\r\nto explore not just the original compositions but all songs performed,\r\nincluding covers by unrelated artists and individuals and bands related\r\nto the Grateful Dead musical world.\r\nOnce the analysis of the Grateful Dead songwriting networks have been\r\nexhausted, the applications of social analysis to the rest of the\r\nGrateful Dead sub-culture are unlimited.\r\n\r\n\r\n\r\n",
    "preview": "posts/welcome/Grateful-Dead-Map-1200x900.png",
    "last_modified": "2022-05-11T00:07:43-04:00",
    "input_file": {},
    "preview_width": 599,
    "preview_height": 449
  }
]
